/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindMapPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null) type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
}

// node_modules/d3-drag/src/noevent.js
var nonpassivecapture = { capture: true, passive: false };
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2) h = (g - b) / s + (g < b) * 6;
    else if (g === max2) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
})(Math.SQRT2, 2, 4);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;
      if (o.state === STARTED) return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max, min } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) {
    return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) {
    return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum = 0, children2 = node.children, i = children2 && children2.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children2[i].value;
  node.value = sum;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0) sum += children2[i].value;
    node.value = sum;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node2(data), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default2,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children2 = v.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children2, i, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };
  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x, y, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x, y, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new ZoomEvent(type2, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type: type2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default3(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default3(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t0 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t1, p0, event);
    else select_default2(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default3(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation2(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default4(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : filter2;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}

// src/managers/UndoManager.ts
var UndoManager = class {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
    this.MAX_STACK_SIZE = 5;
  }
  /**
   * Save current state as a snapshot before modification
   */
  saveSnapshot(data) {
    const snapshot = {
      rootNode: data.rootNode ? this.deepCloneNode(data.rootNode) : null,
      allNodes: data.allNodes.map((node) => this.deepCloneNode(node)),
      maxLevel: data.maxLevel
    };
    if (snapshot.rootNode) {
      this.rebuildParentReferences(snapshot.rootNode);
    }
    this.undoStack.push(snapshot);
    if (this.undoStack.length > this.MAX_STACK_SIZE) {
      const removed = this.undoStack.shift();
    }
    this.redoStack = [];
  }
  /**
   * Undo to previous state
   * @param currentState The current state to save before undoing
   * @returns The previous state, or null if nothing to undo
   */
  undo(currentState) {
    if (this.undoStack.length === 0) {
      return null;
    }
    const snapshot = {
      rootNode: currentState.rootNode ? this.deepCloneNode(currentState.rootNode) : null,
      allNodes: currentState.allNodes.map((node) => this.deepCloneNode(node)),
      maxLevel: currentState.maxLevel
    };
    if (snapshot.rootNode) {
      this.rebuildParentReferences(snapshot.rootNode);
    }
    this.redoStack.push(snapshot);
    return this.undoStack.pop() || null;
  }
  /**
   * Redo to next state
   * @param currentState The current state to save before redoing
   * @returns The next state, or null if nothing to redo
   */
  redo(currentState) {
    if (this.redoStack.length === 0) {
      return null;
    }
    const snapshot = {
      rootNode: currentState.rootNode ? this.deepCloneNode(currentState.rootNode) : null,
      allNodes: currentState.allNodes.map((node) => this.deepCloneNode(node)),
      maxLevel: currentState.maxLevel
    };
    if (snapshot.rootNode) {
      this.rebuildParentReferences(snapshot.rootNode);
    }
    this.undoStack.push(snapshot);
    return this.redoStack.pop() || null;
  }
  /**
   * Check if undo is available
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Check if redo is available
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  /**
   * Get undo stack size (for debugging/UI display)
   */
  getUndoCount() {
    return this.undoStack.length;
  }
  /**
   * Get redo stack size (for debugging/UI display)
   */
  getRedoCount() {
    return this.redoStack.length;
  }
  /**
   * Clear all history (called when loading new file)
   */
  clearHistory() {
    this.undoStack = [];
    this.redoStack = [];
  }
  /**
   * Deep clone a MindMapNode recursively
   */
  deepCloneNode(node) {
    const clone = { ...node };
    if (node.children && Array.isArray(node.children)) {
      clone.children = node.children.map((child) => this.deepCloneNode(child));
    }
    clone.parent = null;
    return clone;
  }
  /**
   * Rebuild parent references for all nodes in the tree
   * This must be called after deep cloning to restore parent links
   */
  rebuildParentReferences(node) {
    if (!node || !node.children || !Array.isArray(node.children)) {
      return;
    }
    for (const child of node.children) {
      child.parent = node;
      this.rebuildParentReferences(child);
    }
  }
};

// src/constants/mindmap-constants.ts
var MINDMAP_IDENTIFIER = "#mindmap";
var MARKDOWN_EXTENSION = "md";
var LAYOUT_CONSTANTS = {
  // Spacing constants
  MIN_NODE_GAP: 25,
  // 
  HORIZONTAL_SPACING: 220,
  // 
  VERTICAL_SPACING: 110,
  // 
  MIN_VERTICAL_GAP: 25,
  // 
  // 
  ADAPTIVE_HORIZONTAL_SPACING: {
    MIN_SPACING: 80,
    // 
    MAX_SPACING: 300,
    // 
    SOURCE_NODE_RATIO: 0.15,
    // 
    TARGET_NODE_RATIO: 0.1,
    // 
    BASE_SPACING: 60,
    // 
    SAFETY_MARGIN: 10
    // 
  },
  // Canvas dimensions (will become dynamic)
  TREE_HEIGHT: 800,
  // 
  TREE_WIDTH: 1400,
  // 
  CANVAS_WIDTH: 1600,
  // 
  CANVAS_HEIGHT: 1e3,
  // 
  // Node spacing
  NODE_HEIGHT_BUFFER: 15,
  // 
  // Centering calculations
  CENTER_OFFSET_X: (1600 - 1600) / 2,
  // 
  CENTER_OFFSET_Y: (1e3 - 1e3) / 2
  // 
};
var STYLE_CONSTANTS = {
  // Font sizes by node level
  ROOT_FONT_SIZE: "20px",
  // 
  LEVEL_1_FONT_SIZE: "18px",
  // 
  DEFAULT_FONT_SIZE: "15px",
  // 13px15px
  // Additional font sizes for UI components
  TEXT_MEASUREMENT_FONT_SIZE: "14px",
  // 
  INTERACTION_UI_FONT_SIZE: "14px",
  // UI
  // Node dimensions
  ROOT_NODE_MIN_WIDTH: 120,
  // 
  NODE_MIN_WIDTH: 100,
  // 
  // Text calculations
  CHAR_WIDTH_RATIO: 0.62,
  // 
  // Timing constants
  RENDER_FRAME_DELAY: 16
  // 
};
var getFontSizeByDepth = (depth) => {
  switch (depth) {
    case 0:
      return STYLE_CONSTANTS.ROOT_FONT_SIZE;
    case 1:
      return STYLE_CONSTANTS.LEVEL_1_FONT_SIZE;
    default:
      return STYLE_CONSTANTS.DEFAULT_FONT_SIZE;
  }
};
var getNumericFontSizeByDepth = (depth) => {
  return parseInt(getFontSizeByDepth(depth).replace("px", ""));
};
var COLOR_CONSTANTS = {
  // Default node colors by level
  ROOT_NODE_COLOR: "#4CAF50",
  // 
  LEVEL_1_COLOR: "#2196F3",
  // 
  DEFAULT_NODE_COLOR: "#666666",
  // 
  // Selection colors
  SELECTED_NODE_COLOR: "#FF9800",
  // 
  HOVER_NODE_COLOR: "#FFC107",
  // 
  // Link colors
  LINK_COLOR: "#999999",
  // 
  LINK_WIDTH: 2
  // 
};
var ANIMATION_CONSTANTS = {
  // Transition durations (in milliseconds)
  FAST_TRANSITION: 150,
  // 
  NORMAL_TRANSITION: 300,
  // 
  SLOW_TRANSITION: 500,
  // 
  // Easing functions
  EASING_DEFAULT: "ease-in-out",
  // 
  EASING_ELASTIC: "elastic"
  // 
};
var PERFORMANCE_CONSTANTS = {
  // Rendering thresholds
  MAX_NODES_BEFORE_VIRTUALIZATION: 500,
  // 
  // Debounce delays (in milliseconds)
  RENDER_DEBOUNCE_DELAY: 100,
  // 
  INPUT_DEBOUNCE_DELAY: 300,
  // 
  // Cache settings
  MAX_CACHE_SIZE: 1e3,
  // 
  CACHE_EXPIRY_TIME: 3e5
  // 5
};
var VALIDATION_CONSTANTS = {
  // Text validation
  MAX_TEXT_LENGTH: 500,
  // 
  INVALID_CHARACTERS: ["	"],
  // 
  // File validation
  MAX_FILE_SIZE: 1024 * 1024
  // 1MB
};

// src/utils/mindmap-utils.ts
function cleanTextContent(text) {
  if (!text) return "";
  return text.replace(/\[([a-zA-Z_][a-zA-Z0-9_]*:[^\]]+)\]/g, "").trim();
}
function getFileNameWithoutExtension(filePath) {
  if (!filePath) return "Untitled";
  const fileName = filePath.replace(/^.*[\\/]/, "");
  return fileName.replace(/\.md$/, "");
}
function isListItem(line) {
  return /^[ \t]*[*\-+]\s+\S/.test(line) || /^[ \t]*\d+\.\s+\S/.test(line);
}
function parseListItem(line) {
  const match = line.match(/^(\s*)([*\-+]?\d*\.?)\s+(.+)$/);
  if (!match) return null;
  const [, indent, , content] = match;
  const level = Math.floor(indent.length / 4);
  return {
    level,
    content: cleanTextContent(content),
    indent
  };
}
function generateMarkdownFromNodes(rootNode) {
  let markdown = MINDMAP_IDENTIFIER + "\n\n";
  const generateNodeMarkdown = (node, indentLevel) => {
    if (node.level === 0) return;
    const indent = "    ".repeat(indentLevel - 1);
    const listPrefix = "*";
    const lines = node.text.split("\n");
    markdown += `${indent}${listPrefix} ${lines[0]}
`;
    const continuationIndent = indent + "  ";
    for (let i = 1; i < lines.length; i++) {
      markdown += `${continuationIndent}${lines[i]}
`;
    }
    for (const child of node.children) {
      generateNodeMarkdown(child, indentLevel + 1);
    }
  };
  for (const child of rootNode.children) {
    generateNodeMarkdown(child, child.level);
  }
  return markdown;
}
function parseMarkdownContent(content, filePath) {
  var _a;
  const lines = content.replace(/^#mindmap\s*\n?/, "").split("\n");
  const allNodes = [];
  const nodeStack = [];
  let maxLevel = 0;
  let rootNode = null;
  let lastNode = null;
  let lastIndentLength = 0;
  const fileName = getFileNameWithoutExtension(filePath);
  rootNode = {
    text: fileName,
    level: 0,
    parent: null,
    children: [],
    expanded: true
  };
  allNodes.push(rootNode);
  nodeStack.push(rootNode);
  for (const line of lines) {
    if (!line.trim()) continue;
    if (isListItem(line)) {
      const parsed = parseListItem(line);
      if (!parsed) continue;
      const { level, content: content2, indent } = parsed;
      const newNode = {
        text: content2,
        level: level + 1,
        // +1  level 0
        parent: null,
        children: [],
        expanded: true
      };
      while (nodeStack.length > level + 1) {
        nodeStack.pop();
      }
      const parentNode = nodeStack[nodeStack.length - 1];
      if (parentNode) {
        newNode.parent = parentNode;
        parentNode.children.push(newNode);
      }
      allNodes.push(newNode);
      nodeStack.push(newNode);
      lastNode = newNode;
      lastIndentLength = indent.length;
      maxLevel = Math.max(maxLevel, newNode.level);
    } else {
      const currentIndent = ((_a = line.match(/^\s*/)) == null ? void 0 : _a[0].length) || 0;
      if (lastNode && currentIndent > lastIndentLength) {
        const lineContent = line.trim();
        if (lineContent) {
          lastNode.text = lastNode.text + "\n" + lineContent;
        }
        continue;
      }
    }
  }
  return {
    rootNode,
    allNodes,
    maxLevel
  };
}
function isMindMapFile(content, extension) {
  return extension === MARKDOWN_EXTENSION && content.trim().startsWith(MINDMAP_IDENTIFIER);
}

// src/utils/TextMeasurer.ts
function setCssProps(element, props) {
  Object.assign(element.style, props);
}
var TextMeasurer = class {
  constructor() {
    //  DOM 
    this.textMeasurementElement = null;
    // 
    this.textMeasurementCache = /* @__PURE__ */ new Map();
    // 
    this.nodeDimensionsCache = /* @__PURE__ */ new Map();
  }
  /**
   * 
   *
   *  DOM 
   *
   * @param text 
   * @param fontSize 
   * @param fontWeight normal/bold
   * @returns 
   */
  measureTextAccurately(text, fontSize, fontWeight = "normal") {
    const cacheKey = `${text}-${fontSize}-${fontWeight}`;
    if (this.textMeasurementCache.has(cacheKey)) {
      const cached = this.textMeasurementCache.get(cacheKey);
      if (cached) {
        return cached;
      }
    }
    this.initializeTextMeasurementElement();
    if (this.textMeasurementElement) {
      setCssProps(this.textMeasurementElement, {
        fontSize: `${fontSize}px`,
        fontWeight
      });
      this.textMeasurementElement.textContent = text;
      const rect = this.textMeasurementElement.getBoundingClientRect();
      const result = {
        width: rect.width,
        height: rect.height
      };
      this.textMeasurementCache.set(cacheKey, result);
      return result;
    }
    const charWidth = fontSize * 0.62;
    const lineHeight = fontSize * 1.2;
    return {
      width: text.length * charWidth,
      height: lineHeight
    };
  }
  /**
   * 
   *
   * 
   *
   * @param text 
   * @param maxWidth null
   * @param fontSize 
   * @returns 
   */
  wrapText(text, maxWidth, fontSize) {
    if (!text || text.length === 0) return [""];
    if (maxWidth === null) {
      if (text.includes("\n")) {
        const lines2 = text.split("\n");
        return lines2;
      }
      return [text];
    }
    const charWidth = fontSize * 0.62;
    const maxChars = Math.floor(maxWidth / charWidth);
    if (text.length <= maxChars) {
      return [text];
    }
    const words = text.split(" ");
    const lines = [];
    let currentLine = "";
    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      if (testLine.length <= maxChars) {
        currentLine = testLine;
      } else {
        if (currentLine) {
          lines.push(currentLine);
        }
        currentLine = word;
      }
    }
    if (currentLine) {
      lines.push(currentLine);
    }
    return lines.length > 0 ? lines : [text.substring(0, maxChars)];
  }
  /**
   * 
   *
   * @param lines 
   * @param fontSize 
   * @param fontWeight 
   * @returns 
   */
  measureTextSize(lines, fontSize, fontWeight = "normal") {
    if (lines.length === 0) {
      return { width: 40, height: fontSize * 1.3 };
    }
    const lineHeight = fontSize * 1.3;
    let maxWidth = 0;
    for (const line of lines) {
      const measurement = this.measureTextAccurately(line, fontSize, fontWeight);
      if (measurement.width > maxWidth) {
        maxWidth = measurement.width;
      }
    }
    const height = lines.length * lineHeight;
    const width = Math.max(maxWidth, 35);
    const result = { width: Math.ceil(width), height: Math.ceil(height) };
    return result;
  }
  /**
   * 
   *
   * 
   * 
   *
   * @param depth 0=1=2+=
   * @param text 
   * @returns 
   */
  getNodeDimensions(depth, text) {
    const cacheKey = `${depth}-${text}-${text.length}`;
    if (this.nodeDimensionsCache.has(cacheKey)) {
      const cached = this.nodeDimensionsCache.get(cacheKey);
      if (cached) {
        return cached;
      }
    }
    const cleanedText = cleanTextContent(text);
    let fontSize;
    let fontWeight;
    let maxWidth;
    let minWidth;
    let padding;
    if (depth === 0) {
      fontSize = getFontSizeByDepth(0);
      fontWeight = "bold";
      maxWidth = null;
      minWidth = 40;
      padding = 18;
    } else if (depth === 1) {
      fontSize = getFontSizeByDepth(1);
      fontWeight = "bold";
      maxWidth = null;
      minWidth = 38;
      padding = 16;
    } else {
      fontSize = getFontSizeByDepth(depth);
      fontWeight = "normal";
      maxWidth = null;
      minWidth = 20;
      padding = 10;
    }
    const fontSizeNum = parseInt(fontSize);
    const effectiveMaxWidth = maxWidth !== null ? maxWidth - padding * 2 : null;
    const lines = this.wrapText(cleanedText, effectiveMaxWidth, fontSizeNum);
    const textSize = this.measureTextSize(lines, fontSizeNum, fontWeight);
    const safetyBuffer = Math.max(8, textSize.width * 0.05);
    const width = Math.max(textSize.width + padding * 2 + safetyBuffer, minWidth);
    const height = Math.max(textSize.height + padding * 2, fontSizeNum * 2);
    const textX = width / 2;
    const textY = textSize.height / 2 + padding / 2;
    const result = {
      width,
      height,
      textX,
      textY,
      fontSize,
      fontWeight,
      lines,
      padding,
      minWidth,
      maxWidth
    };
    this.nodeDimensionsCache.set(cacheKey, result);
    return result;
  }
  /**
   * 
   *
   * 
   *
   * @param text 
   */
  clearNodeDimensionsCacheForText(text) {
    const keysToDelete = [];
    for (const key of this.nodeDimensionsCache.keys()) {
      if (key.includes(text)) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach((key) => this.nodeDimensionsCache.delete(key));
    const textKeysToDelete = [];
    for (const key of this.textMeasurementCache.keys()) {
      if (key.includes(text)) {
        textKeysToDelete.push(key);
      }
    }
    textKeysToDelete.forEach((key) => this.textMeasurementCache.delete(key));
  }
  /**
   * 
   *
   *  DOM 
   */
  initializeTextMeasurementElement() {
    if (!this.textMeasurementElement) {
      this.textMeasurementElement = document.createElement("div");
      this.textMeasurementElement.addClass("mindmap-text-measurer");
      document.body.appendChild(this.textMeasurementElement);
    }
  }
  /**
   * 
   *
   *  DOM 
   */
  destroy() {
    if (this.textMeasurementElement && this.textMeasurementElement.parentNode) {
      this.textMeasurementElement.parentNode.removeChild(this.textMeasurementElement);
      this.textMeasurementElement = null;
    }
    this.textMeasurementCache.clear();
    this.nodeDimensionsCache.clear();
  }
};

// src/renderers/layout-calculator.ts
var LayoutCalculator = class {
  constructor(config = {}) {
    this.config = {
      minNodeGap: LAYOUT_CONSTANTS.MIN_NODE_GAP,
      horizontalSpacing: LAYOUT_CONSTANTS.HORIZONTAL_SPACING,
      verticalSpacing: LAYOUT_CONSTANTS.VERTICAL_SPACING,
      minVerticalGap: LAYOUT_CONSTANTS.MIN_VERTICAL_GAP,
      treeHeight: LAYOUT_CONSTANTS.TREE_HEIGHT,
      treeWidth: LAYOUT_CONSTANTS.TREE_WIDTH,
      nodeHeightBuffer: LAYOUT_CONSTANTS.NODE_HEIGHT_BUFFER,
      ...config
    };
  }
  /**
   * Create D3 tree layout
   */
  createTreeLayout() {
    return tree_default().nodeSize([this.config.minNodeGap, this.config.minNodeGap]).separation((a, b) => this.calculateDynamicSeparation(a, b));
  }
  /**
   * Calculate dynamic separation between nodes
   */
  calculateDynamicSeparation(a, b) {
    return (a.parent === b.parent ? 1 : 2) / a.depth;
  }
  /**
   * 
   * 
   * @param sourceWidth 
   * @param targetWidth 
   * @returns 
   */
  calculateAdaptiveHorizontalSpacing(sourceWidth, targetWidth) {
    const { ADAPTIVE_HORIZONTAL_SPACING } = LAYOUT_CONSTANTS;
    const sourceBasedSpacing = sourceWidth * ADAPTIVE_HORIZONTAL_SPACING.SOURCE_NODE_RATIO;
    const targetBasedSpacing = targetWidth * ADAPTIVE_HORIZONTAL_SPACING.TARGET_NODE_RATIO;
    const calculatedSpacing = Math.max(sourceBasedSpacing, targetBasedSpacing) + ADAPTIVE_HORIZONTAL_SPACING.BASE_SPACING;
    const finalSpacing = Math.max(
      ADAPTIVE_HORIZONTAL_SPACING.MIN_SPACING,
      Math.min(ADAPTIVE_HORIZONTAL_SPACING.MAX_SPACING, calculatedSpacing)
    );
    return finalSpacing + ADAPTIVE_HORIZONTAL_SPACING.SAFETY_MARGIN;
  }
  /**
   * 
   * @param node 
   * @returns 
   */
  estimateNodeDimensions(node) {
    const fontSize = 14;
    const charWidth = fontSize * 0.6;
    const padding = 15;
    const width = Math.max(100, node.text.length * charWidth + padding * 2);
    const height = fontSize + padding * 2;
    return {
      width,
      height,
      fontSize: `${fontSize}px`,
      padding
    };
  }
  /**
   * 
   * @param parentNode 
   * @param childNodes 
   * @returns 
   */
  calculateHorizontalSpacingForFamily(parentNode, childNodes) {
    const parentDimensions = this.estimateNodeDimensions(parentNode);
    if (!childNodes || childNodes.length === 0) {
      return this.calculateAdaptiveHorizontalSpacing(parentDimensions.width, 100);
    }
    let maxChildWidth = 0;
    for (const childNode of childNodes) {
      const childDimensions = this.estimateNodeDimensions(childNode);
      maxChildWidth = Math.max(maxChildWidth, childDimensions.width);
    }
    return this.calculateAdaptiveHorizontalSpacing(parentDimensions.width, maxChildWidth);
  }
  /**
   * 
   * @param root D3
   * @param nodeDimensionsCallback 
   */
  createCustomTreeLayout(root2, nodeDimensionsCallback) {
    this.createRecursiveTreeLayout(root2, nodeDimensionsCallback);
  }
  /**
   * 
   *
   * 
   *
   * 
   *
   * 
   *   Markdown 
   *    D3                
   * 
   *
   *
   * 
   *
   * 1 D3.hierarchy() 
   *   - { text: "root", children: [...] }
   *   -  parent, children, depth 
   *
   * 21 - calculateAllSubtreeDimensions
   *   
   *     from leaves to root                   
   *                                  
   *        subtreeHeight = nodeHeight   
   *                                  
   *                                         
   *                                  
   *        subtreeHeight = sum() 
   *                                  
   *   
   *   -  D3.eachAfter() 
   *   - 
   *   -  subtreeWidth  subtreeHeight
   *
   * 32 - setNodePositionsTopDown
   *   
   *     from root to leaves                   
   *                                  
   *       x=100, y=100                
   *                                  
   *                                        
   *                             
   *     1  2    y    
   *     x=50 x=150  x  
   *                             
   *   
   *   - 
   *   -  (x, y) 
   *   - 
   *   -  y 
   *
   *
   *  
   *
   * 
   *   - node.x: 
   *   - node.y: 
   *
   * 
   *   - startX = 100: 
   *   - startY = 100: 
   *
   *
   * 
   *
   * O(N) N 
   * - 1: 
   * - 2: 
   * - : 2N  = O(N)
   *
   *
   * 
   *
   * ```typescript
   * const calculator = new LayoutCalculator();
   *
   * // 
   * const flatData = {
   *     text: "Root",
   *     children: [
   *         { text: "Child 1" },
   *         { text: "Child 2" }
   *     ]
   * };
   *
   * // 
   * const root = d3.hierarchy(flatData);
   *
   * // 
   * calculator.createRecursiveTreeLayout(root, nodeDimensionsFn);
   *
   * // 
   * // root.x, root.y: 
   * // root.children[0].x, root.children[0].y: 
   * // root.data.subtreeWidth, root.data.subtreeHeight: 
   * ```
   *
   *
   * 
   *
   *   root  x, y 
   *  nodeDimensionsCallback 
   *  
   *  
   *
   *
   * @param root D3 d3.hierarchy() 
   * @param nodeDimensionsCallback 
   *                              (depth: number, text: string)
   *                              { width: number, height: number }
   * @returns void root 
   *
   * @see calculateAllSubtreeDimensions() - 1
   * @see setNodePositionsTopDown() - 2
   * @see distributeChildrenVerticalSpace() - 
   */
  createRecursiveTreeLayout(root2, nodeDimensionsCallback) {
    this.calculateAllSubtreeDimensions(root2, nodeDimensionsCallback);
    const startX = 100;
    const startY = 100;
    this.setNodePositionsTopDown(root2, startX, startY, nodeDimensionsCallback);
  }
  /**
   * 
   *  D3  eachAfter 
   * @param root 
   * @param nodeDimensionsCallback 
   */
  calculateAllSubtreeDimensions(root2, nodeDimensionsCallback) {
    root2.eachAfter((node) => {
      const dims = nodeDimensionsCallback(node.depth, node.data.text);
      node.data.nodeWidth = dims.width;
      node.data.nodeHeight = dims.height;
      if (!node.children || node.children.length === 0) {
        node.data.subtreeWidth = dims.width;
        node.data.subtreeHeight = dims.height;
      } else {
        const childSubtrees = node.children.map((c) => ({
          width: c.data.subtreeWidth || 0,
          height: c.data.subtreeHeight || 0
        }));
        const maxChildWidth = Math.max(...childSubtrees.map((s) => s.width));
        node.data.subtreeWidth = Math.max(dims.width, maxChildWidth);
        const verticalGap = 10;
        let totalHeight = 0;
        node.children.forEach((child, index) => {
          totalHeight += child.data.subtreeHeight || 0;
          if (index < node.children.length - 1) {
            totalHeight += verticalGap;
          }
        });
        node.data.subtreeHeight = Math.max(dims.height, totalHeight);
      }
    });
  }
  /**
   * 
   * @param node 
   * @param x X
   * @param y Y
   * @param nodeDimensionsCallback 
   */
  setNodePositionsTopDown(node, x, y, nodeDimensionsCallback) {
    node.x = x;
    node.y = y;
    if (!node.children || node.children.length === 0) {
      return;
    }
    this.distributeChildrenVerticalSpace(node, nodeDimensionsCallback);
  }
  /**
   * 
   * @param parentNode 
   * @param nodeDimensionsCallback 
   */
  distributeChildrenVerticalSpace(parentNode, nodeDimensionsCallback) {
    const children2 = parentNode.children;
    if (!children2 || children2.length === 0) return;
    const horizontalSpacing = parentNode.depth === 0 ? 80 : 30;
    const verticalGap = 10;
    let totalChildrenHeight = 0;
    children2.forEach((child, index) => {
      const childHeight = child.data.subtreeHeight || 0;
      totalChildrenHeight += childHeight;
      if (index < children2.length - 1) {
        totalChildrenHeight += verticalGap;
      }
    });
    let currentY = parentNode.x - totalChildrenHeight / 2;
    children2.forEach((child, index) => {
      const childX = currentY + (child.data.subtreeHeight || 0) / 2;
      const childY = parentNode.y + (parentNode.data.nodeWidth || 0) + horizontalSpacing;
      this.setNodePositionsTopDown(child, childX, childY, nodeDimensionsCallback);
      currentY += (child.data.subtreeHeight || 0) + verticalGap;
    });
  }
  /**
   * 
   * @param root 
   * @param nodeDimensionsCallback 
   */
  calculateLeftAlignedHorizontalPositions(root2, nodeDimensionsCallback) {
    const nodeGroups = this.groupNodesByParent(root2);
    const rootDimensions = nodeDimensionsCallback(root2.depth, root2.data.text);
    root2.y = 50;
    this.processNodeGroupsByLevel(nodeGroups, nodeDimensionsCallback);
  }
  /**
   * 
   * @param root 
   * @returns ID
   */
  groupNodesByParent(root2) {
    const groups = /* @__PURE__ */ new Map();
    root2.each((node) => {
      if (node.depth > 0 && node.parent) {
        const parentId = node.parent.data.text;
        if (!groups.has(parentId)) {
          groups.set(parentId, []);
        }
        const group = groups.get(parentId);
        if (group) {
          group.push(node);
        }
      }
    });
    return groups;
  }
  /**
   * 
   * @param nodeGroups 
   * @param nodeDimensionsCallback 
   */
  processNodeGroupsByLevel(nodeGroups, nodeDimensionsCallback) {
    for (const [parentText, childNodes] of nodeGroups) {
      if (childNodes.length === 0) continue;
      const firstChild = childNodes[0];
      if (!firstChild.parent) {
        continue;
      }
      const parentNode = firstChild.parent;
      const parentDimensions = nodeDimensionsCallback(parentNode.depth, parentNode.data.text);
      const parentRightEdge = parentNode.y + parentDimensions.width;
      let maxChildWidth = 0;
      for (const child of childNodes) {
        const childDimensions = nodeDimensionsCallback(child.depth, child.data.text);
        maxChildWidth = Math.max(maxChildWidth, childDimensions.width);
      }
      const adaptiveSpacing = this.calculateAdaptiveHorizontalSpacing(
        parentDimensions.width,
        maxChildWidth
      );
      const unifiedLeftEdge = parentRightEdge + adaptiveSpacing;
      for (const child of childNodes) {
        child.y = unifiedLeftEdge;
      }
    }
    this.processNextLevelGroups(nodeGroups, nodeDimensionsCallback);
  }
  /**
   * 
   * @param nodeGroups 
   * @param nodeDimensionsCallback 
   */
  processNextLevelGroups(nodeGroups, nodeDimensionsCallback) {
    const nextLevelGroups = /* @__PURE__ */ new Map();
    for (const childNodes of nodeGroups.values()) {
      for (const child of childNodes) {
        if (child.children && child.children.length > 0) {
          const childText = child.data.text;
          if (!nextLevelGroups.has(childText)) {
            nextLevelGroups.set(childText, []);
          }
          const group = nextLevelGroups.get(childText);
          if (group) {
            group.push(...child.children);
          }
        }
      }
    }
    if (nextLevelGroups.size > 0) {
      this.processNodeGroupsByLevel(nextLevelGroups, nodeDimensionsCallback);
    }
  }
  /**
   * Calculate tree dimensions
   */
  calculateTreeDimensions(root2) {
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    root2.each((node) => {
      if (node.x !== void 0) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
      }
      if (node.y !== void 0) {
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });
    const width = maxX - minX || this.config.treeWidth;
    const height = maxY - minY || this.config.treeHeight;
    return { width, height };
  }
  /**
   * Apply offsets to center the tree
   */
  centerTree(root2, canvasWidth, canvasHeight) {
    const { width, height } = this.calculateTreeDimensions(root2);
    const offsetX = (canvasWidth - width) / 2;
    const offsetY = (canvasHeight - height) / 2;
    root2.each((node) => {
      if (node.x !== void 0) {
        node.x += offsetX;
      }
      if (node.y !== void 0) {
        node.y += offsetY;
      }
    });
    return { offsetX, offsetY };
  }
  /**
   * Get layout configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update layout configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
};

// src/utils/coordinate-system.ts
var CoordinateConverter = class {
  /**
   * YX
   *
   * 
   * Y
   * X
   * 
   *
   * @param layoutY Y
   * @param offsetX X0
   * @returns X
   *
   * @example
   * ```typescript
   * const canvasX = CoordinateConverter.toCanvasX(200, 0);
   * // : 200 ()
   * ```
   */
  static toCanvasX(layoutY, offsetX = 0) {
    return layoutY + offsetX;
  }
  /**
   * XY
   *
   * 
   * X
   * Y
   * 
   *
   * 
   * SVGrect(0, 0)
   *  layoutXrecty layoutX - height/2
   *
   * @param layoutX X
   * @param nodeHeight 
   * @param offsetY Y0
   * @returns Y
   *
   * @example
   * ```typescript
   * const canvasY = CoordinateConverter.toCanvasY(100, 50, 0);
   * // : 75 (100 - 50/2)
   * // : 1005075
   * ```
   */
  static toCanvasY(layoutX, nodeHeight, offsetY = 0) {
    return layoutX + offsetY - nodeHeight / 2;
  }
  /**
   * YX
   *
   * 
   * toCanvasY 
   * 
   *
   * @param canvasY Y
   * @param nodeHeight 
   * @param offsetY Y0
   * @returns X
   *
   * @example
   * ```typescript
   * const layoutX = CoordinateConverter.toLayoutX(75, 50, 0);
   * // : 100 (75 + 50/2)
   * ```
   */
  static toLayoutX(canvasY, nodeHeight, offsetY = 0) {
    return canvasY - offsetY + nodeHeight / 2;
  }
  /**
   * X
   *
   * 
   * 
   *
   * @param layoutY Y
   * @param nodeWidth 
   * @param padding 
   * @param lineOffset 
   * @param offsetX X
   * @returns X
   *
   * @example
   * ```typescript
   * const rightEdge = CoordinateConverter.toRightEdge(200, 100, 20, 6, 0);
   * // : 286 (200 + 100 - 20 + 6)
   * ```
   */
  static toRightEdge(layoutY, nodeWidth, padding, lineOffset, offsetX = 0) {
    return layoutY + nodeWidth - padding + lineOffset + offsetX;
  }
  /**
   * Xpadding
   *
   * 
   * 
   *
   * @param layoutY Y
   * @param padding 
   * @param lineOffset 
   * @param offsetX X
   * @returns Xpadding
   *
   * @example
   * ```typescript
   * const leftEdge = CoordinateConverter.toLeftEdge(400, 20, 6, 0);
   * // : 414 (400 + 20 - 6)
   * ```
   */
  static toLeftEdge(layoutY, padding, lineOffset, offsetX = 0) {
    return layoutY + padding - lineOffset + offsetX;
  }
  /**
   * 
   *
   * 
   * 
   * 
   *
   * @param canvasX X
   * @param canvasY Y
   * @param width 
   * @param height 
   * @returns 
   *
   * @example
   * ```typescript
   * const bounds = CoordinateConverter.getNodeBounds(100, 75, 50, 50);
   * // : { x: 100, y: 75, right: 150, bottom: 125, width: 50, height: 50 }
   * ```
   */
  static getNodeBounds(canvasX, canvasY, width, height) {
    return {
      x: canvasX,
      y: canvasY,
      right: canvasX + width,
      bottom: canvasY + height,
      width,
      height
    };
  }
  /**
   * 
   *
   * 
   * 
   * 
   *
   * @param layoutX1 X
   * @param layoutX2 X
   * @returns 
   *
   * @example
   * ```typescript
   * const distance = CoordinateConverter.getVerticalDistance(75, 193);
   * // : 118 (|75 - 193|)
   * ```
   */
  static getVerticalDistance(layoutX1, layoutX2) {
    return Math.abs(layoutX1 - layoutX2);
  }
  /**
   * 
   *
   * 
   * 
   * 
   *
   * @param layoutX1 X
   * @param height1 
   * @param layoutX2 X
   * @param height2 
   * @param gap 0
   * @returns 
   *
   * @example
   * ```typescript
   * const overlaps = CoordinateConverter.isOverlapping(
   *   75, 176,  // 1: 75176
   *   193, 40,  // 2: 19340
   *   10        // 10px
   * );
   * // 
   * // 1: 75 - 88 = -13  75 + 88 = 163
   * // 2: 193 - 20 = 173  193 + 20 = 213
   * // : 173 - 163 = 10px
   * // : false
   * ```
   */
  static isOverlapping(layoutX1, height1, layoutX2, height2, gap = 0) {
    const top1 = layoutX1 - height1 / 2;
    const bottom1 = layoutX1 + height1 / 2;
    const top2 = layoutX2 - height2 / 2;
    const bottom2 = layoutX2 + height2 / 2;
    return !(bottom1 + gap <= top2 || bottom2 + gap <= top1);
  }
  /**
   * transform
   *
   * 
   * SVG transform
   *
   * @param layoutX X
   * @param layoutY Y
   * @param nodeWidth 
   * @param nodeHeight 
   * @param offsetX X
   * @param offsetY Y
   * @returns transform "translate(200, 75)"
   *
   * @example
   * ```typescript
   * const transform = CoordinateConverter.createTransform(100, 200, 100, 50, 0, 0);
   * // : "translate(200, 75)"
   * // : X=200 (), Y=75 (100 - 50/2)
   * ```
   */
  static createTransform(layoutX, layoutY, nodeWidth, nodeHeight, offsetX = 0, offsetY = 0) {
    const canvasX = this.toCanvasX(layoutY, offsetX);
    const canvasY = this.toCanvasY(layoutX, nodeHeight, offsetY);
    return `translate(${canvasX}, ${canvasY})`;
  }
  /**
   * 
   *
   * 
   * 
   * 
   *
   * @param layoutX1 X
   * @param height1 
   * @param layoutX2 X
   * @param height2 
   * @returns 
   *
   * @example
   * ```typescript
   * const gap = CoordinateConverter.calculateActualGap(
   *   75, 176,   // 1: 75, 176
   *   193, 40    // 2: 193, 40
   * );
   * // 
   * // 1: 75 + 88 = 163
   * // 2: 193 - 20 = 173
   * // : 173 - 163 = 10px
   * // : 10
   * ```
   */
  static calculateActualGap(layoutX1, height1, layoutX2, height2) {
    const bottom1 = layoutX1 + height1 / 2;
    const top2 = layoutX2 - height2 / 2;
    return top2 - bottom1;
  }
};

// src/renderers/core/NodeRenderer.ts
var NodeRenderer = class {
  constructor(textMeasurer, layoutCalculator) {
    this.textMeasurer = textMeasurer;
    this.layoutCalculator = layoutCalculator;
  }
  /**
   * 
   *
   * @param svg SVG
   * @param nodes D3
   * @param offsetX X
   * @param offsetY Y
   * @returns D3
   */
  renderNodes(svg, nodes, offsetX, offsetY) {
    const nodeGroup = svg.append("g").attr("class", "nodes");
    const nodeElements = nodeGroup.selectAll("g").data(nodes).enter().append("g").attr("transform", (d) => {
      const dims = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);
      const transform2 = CoordinateConverter.createTransform(
        d.x,
        // X
        d.y,
        // Y
        dims.width,
        // 
        dims.height,
        // 
        offsetX,
        // X
        offsetY
        // Y
      );
      return transform2;
    }).attr("role", "button").attr("aria-label", (d) => `Mind map node: ${d.data.text}`).attr("tabindex", "0").attr("aria-level", (d) => d.depth + 1);
    const nodeRects = nodeElements.append("rect").attr("class", "node-rect").attr("width", (d) => {
      const dims = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);
      return dims.width;
    }).attr("height", (d) => {
      const dims = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);
      return dims.height;
    }).attr("x", 0).attr("y", 0).attr("rx", 6).attr("ry", 6).attr("fill", (d) => {
      if (d.depth === 0) return "#2972f4";
      return "#f3f5f7";
    }).attr("stroke", (d) => {
      if (d.depth === 0) return "#2972f4";
      return "none";
    }).attr("stroke-width", (d) => d.depth === 0 ? 2 : 0).style("cursor", "pointer");
    nodeRects.classed("selected-rect", (d) => d.data.selected || false);
    return nodeElements;
  }
  /**
   * 
   *
   * @param nodeData 
   * @param dimensions 
   * @param offsetX X
   * @param offsetY Y
   * @returns 
   */
  createNodeGroup(nodeData, dimensions, offsetX, offsetY) {
    throw new Error("Method not implemented. Use renderNodes() instead.");
  }
  /**
   * 
   *
   * @param nodeElement 
   * @param nodeData 
   * @param dimensions 
   * @returns 
   */
  createNodeRect(nodeElement, nodeData, dimensions) {
    throw new Error("Method not implemented. Rects are created in renderNodes().");
  }
  /**
   * padding
   *
   * @param depth 
   * @returns padding
   */
  getNodePadding(depth) {
    if (depth === 0) return 24;
    else if (depth === 1) return 20;
    else return 16;
  }
};

// src/renderers/core/LinkRenderer.ts
var LinkRenderer = class {
  constructor(textMeasurer, config) {
    this.textMeasurer = textMeasurer;
    this.config = {
      lineOffset: (config == null ? void 0 : config.lineOffset) || 6
    };
  }
  /**
   * 
   *
   * @param svg SVG
   * @param links D3
   * @param offsetX X
   * @param offsetY Y
   */
  renderLinks(svg, links, offsetX, offsetY) {
    const linkGroup = svg.append("g").attr("class", "links");
    if (links.length === 0) return;
    const rootToFirstLevelLinks = [];
    const roundedLinks = [];
    links.forEach((link) => {
      if (link.source.depth === 0 && link.target.depth === 1) {
        rootToFirstLevelLinks.push(link);
      } else {
        roundedLinks.push(link);
      }
    });
    if (rootToFirstLevelLinks.length > 0) {
      this.renderRootToFirstLevelCubicLinks(linkGroup, rootToFirstLevelLinks, offsetX, offsetY);
    }
    if (roundedLinks.length > 0) {
      this.renderRoundedLinks(linkGroup, roundedLinks, offsetX, offsetY);
    }
  }
  /**
   * 
   *
   * @param group SVG
   * @param links 
   * @param offsetX X
   * @param offsetY Y
   */
  renderRootToFirstLevelCubicLinks(group, links, offsetX, offsetY) {
    links.forEach((link) => {
      const connectionPoints = this.getLinkConnectionPoints(link, offsetX, offsetY);
      const sourceX = connectionPoints.sourceX;
      const sourceY = connectionPoints.sourceY;
      const targetX = connectionPoints.targetX;
      const targetY = connectionPoints.targetY;
      const deltaX = targetX - sourceX;
      const deltaY = targetY - sourceY;
      const control1X = sourceX + deltaX * 0.3;
      const control1Y = sourceY;
      const control2X = targetX - deltaX * 0.3;
      const control2Y = targetY;
      const pathData = `M ${sourceX},${sourceY} C ${control1X},${control1Y} ${control2X},${control2Y} ${targetX},${targetY}`;
      group.append("path").attr("d", pathData).attr("stroke", "#b8b8b8").attr("stroke-width", 2).attr("fill", "none").attr("stroke-linecap", "round").style("opacity", 0.8).attr("class", "root-to-first-level-link");
    });
  }
  /**
   * 0-1
   *
   * @param group SVG
   * @param links 
   * @param offsetX X
   * @param offsetY Y
   */
  renderRoundedLinks(group, links, offsetX, offsetY) {
    links.forEach((link) => {
      const connectionPoints = this.getLinkConnectionPoints(link, offsetX, offsetY);
      const sourceX = connectionPoints.sourceX;
      const sourceY = connectionPoints.sourceY;
      const targetX = connectionPoints.targetX;
      const targetY = connectionPoints.targetY;
      const pathData = this.generateRoundedPath(sourceX, sourceY, targetX, targetY, 8);
      group.append("path").attr("d", pathData).attr("stroke", "#b8b8b8").attr("stroke-width", 2).attr("fill", "none").attr("stroke-linecap", "round").attr("stroke-linejoin", "round").style("opacity", 0.8).attr("class", "rounded-link");
    });
  }
  /**
   * 
   *
   * @param sourceX X
   * @param sourceY Y
   * @param targetX X
   * @param targetY Y
   * @param cornerRadius 
   * @returns SVG path d
   */
  generateRoundedPath(sourceX, sourceY, targetX, targetY, cornerRadius = 8) {
    const horizontalDistance = targetX - sourceX;
    const turn1X = sourceX + horizontalDistance * 0.45;
    const radius = Math.min(
      cornerRadius,
      Math.abs(targetX - turn1X) * 0.4,
      Math.abs(targetY - sourceY) * 0.4
    );
    const verticalEndY = targetY + (sourceY < targetY ? -radius : radius);
    const cornerStartX = turn1X;
    const cornerStartY = verticalEndY;
    const cornerEndX = turn1X + (targetX > turn1X ? radius : -radius);
    const cornerEndY = targetY;
    return `M ${sourceX},${sourceY}
			L ${turn1X},${sourceY}
			L ${cornerStartX},${cornerStartY}
			Q ${cornerStartX},${targetY} ${cornerEndX},${cornerEndY}
			L ${targetX},${targetY}`;
  }
  /**
   * 
   *
   * 
   * - link.source.y (X), link.source.x (Y)
   * - link.target.y (X), link.target.x (Y)
   *
   * @param link D3
   * @param offsetX X
   * @param offsetY Y
   * @returns 
   */
  getLinkConnectionPoints(link, offsetX, offsetY) {
    const sourceDimensions = this.textMeasurer.getNodeDimensions(
      link.source.depth,
      link.source.data.text
    );
    const targetDimensions = this.textMeasurer.getNodeDimensions(
      link.target.depth,
      link.target.data.text
    );
    const sourcePadding = this.getNodePadding(link.source.depth);
    const targetPadding = this.getNodePadding(link.target.depth);
    const sourceX = CoordinateConverter.toRightEdge(
      link.source.y,
      // Y
      sourceDimensions.width,
      // 
      sourcePadding,
      // padding
      this.config.lineOffset,
      // 
      offsetX
    );
    const targetX = CoordinateConverter.toLeftEdge(
      link.target.y,
      // Y
      targetPadding,
      // padding
      this.config.lineOffset,
      // 
      offsetX
    );
    const sourceY = CoordinateConverter.toCanvasY(link.source.x, 0, offsetY);
    const targetY = CoordinateConverter.toCanvasY(link.target.x, 0, offsetY);
    return { sourceX, sourceY, targetX, targetY };
  }
  /**
   * padding
   *
   * @param depth 
   * @returns padding
   */
  getNodePadding(depth) {
    if (depth === 0) return 24;
    else if (depth === 1) return 20;
    else return 16;
  }
};

// src/renderers/core/TextRenderer.ts
var TextRenderer = class _TextRenderer {
  constructor(textMeasurer, config, editingState, onTextEdit) {
    this.textMeasurer = textMeasurer;
    this.config = config;
    this.editingState = editingState;
    this.onTextEdit = onTextEdit;
  }
  /**
   * 
   *
   * @param nodeElements 
   * @param onEditCallback 
   * @param parentContext saveNodeText
   */
  renderText(nodeElements, onEditCallback, parentContext) {
    const self = parentContext || this;
    nodeElements.each(function(d) {
      const dimensions = self.textMeasurer.getNodeDimensions(d.depth, d.data.text);
      const nodeElement = select_default2(this);
      const isCenterAligned = d.depth === 0 || d.depth === 1;
      const textForeignObject = nodeElement.append("foreignObject").attr("class", "node-text-layer").attr("width", dimensions.width).attr("height", dimensions.height).attr("x", 0).attr("y", 0);
      const textDiv = textForeignObject.append("xhtml:div").attr("contenteditable", "false").attr("class", "node-unified-text").style("width", "100%").style("height", "100%").style("padding", `${dimensions.padding}px`).style("font-size", dimensions.fontSize).style("font-weight", dimensions.fontWeight).style("color", d.depth === 0 ? "#ffffff" : "#000000").style("text-align", isCenterAligned ? "center" : "left").style("outline", "none").style("border", "none").style("background", "transparent").style("word-wrap", "normal").style("white-space", "pre").style("overflow", "visible").style("box-sizing", "border-box").style("font-family", "var(--font-text)").style("line-height", "1.3").style("cursor", "pointer");
      const textDivNode = textDiv.node();
      if (textDivNode) {
        textDivNode.textContent = d.data.text;
        const nodeTextClass = `node-${d.data.text.replace(/\s+/g, "-")}`;
        nodeElement.classed(nodeTextClass, true);
        if (parentContext && parentContext instanceof Object) {
          _TextRenderer.attachTextEditHandlersToNode(textDivNode, d, onEditCallback, self);
        }
      }
    });
  }
  /**
   * 
   *
   * @param textDivNode div
   * @param nodeData 
   * @param onEditCallback 
   * @param parentContext D3TreeRenderer
   */
  static attachTextEditHandlersToNode(textDivNode, nodeData, onEditCallback, parentContext) {
    if (!parentContext) {
      return;
    }
    const config = parentContext.config;
    const editingState = parentContext.editingState;
    textDivNode.addEventListener("keydown", (event) => {
      var _a, _b;
      if (textDivNode.contentEditable === "true") {
        if (event.key === "Enter") {
          if (config == null ? void 0 : config.isMobile) {
            event.preventDefault();
            event.stopPropagation();
            const selection2 = window.getSelection();
            if (selection2 && selection2.rangeCount > 0) {
              const range = selection2.getRangeAt(0);
              range.deleteContents();
              const textNode = document.createTextNode("\n");
              range.insertNode(textNode);
              range.setStartAfter(textNode);
              range.setEndAfter(textNode);
              selection2.removeAllRanges();
              selection2.addRange(range);
            }
            return;
          }
          if (event.altKey) {
            event.preventDefault();
            event.stopPropagation();
          } else {
            event.preventDefault();
            event.stopPropagation();
            (_a = parentContext.saveNodeText) == null ? void 0 : _a.call(parentContext);
          }
        } else if (event.key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
          (_b = parentContext.cancelEditMode) == null ? void 0 : _b.call(parentContext);
        } else if (event.key === "Backspace") {
          const selection2 = window.getSelection();
          if (selection2 && selection2.rangeCount > 0) {
            const range = selection2.getRangeAt(0);
            const node = range.startContainer;
            if (node.nodeType === Node.TEXT_NODE) {
              const textContent = node.textContent || "";
              if (range.startOffset > 0 && textContent[range.startOffset - 1] === "\n") {
                event.preventDefault();
                event.stopPropagation();
                range.setStart(node, range.startOffset - 1);
                range.deleteContents();
              }
            }
          }
        }
        if (onEditCallback) {
          onEditCallback(event, textDivNode);
        }
      }
    });
    textDivNode.addEventListener("keyup", (event) => {
      if (textDivNode.contentEditable === "true") {
        if (event.key === "Enter" && event.altKey) {
          const selection2 = window.getSelection();
          if (selection2 && selection2.rangeCount > 0) {
            const range = selection2.getRangeAt(0);
            range.deleteContents();
            const textNode = document.createTextNode("\n");
            range.insertNode(textNode);
            range.setStartAfter(textNode);
            range.setEndAfter(textNode);
            selection2.removeAllRanges();
            selection2.addRange(range);
          }
        }
      }
    });
    textDivNode.addEventListener("blur", () => {
      if (textDivNode.contentEditable === "true" && (editingState == null ? void 0 : editingState.editElement) === textDivNode) {
        setTimeout(() => {
          var _a;
          if ((editingState == null ? void 0 : editingState.editElement) === textDivNode) {
            (_a = parentContext.saveNodeText) == null ? void 0 : _a.call(parentContext);
          }
        }, 150);
      }
    });
  }
  /**
   * 
   *
   * @param editingState 
   */
  updateEditingState(editingState) {
    this.editingState = editingState;
  }
  /**
   * 
   *
   * @param parentContext 
   */
  updateParentContext(parentContext) {
    this.onTextEdit = ((event, textDivNode) => {
    });
  }
};

// src/interactions/MouseInteraction.ts
var MouseInteraction = class {
  // ==========  ==========
  constructor(callbacks) {
    this.callbacks = callbacks;
    // ==========  ==========
    /**  */
    this.selectedNode = null;
    /**  */
    this.hoveredNode = null;
    // 
    this.clickTimeout = null;
    this.lastClickTime = 0;
    this.clickNode = null;
    this.options = {
      doubleClickTimeout: 300,
      enableCanvasDrag: true,
      ...callbacks
    };
  }
  // ==========  API ==========
  /**
   * 
   *
   * @param nodeElements D3 
   */
  attachNodeClickHandlers(nodeElements) {
    nodeElements.each((d, i, nodes) => {
      const nodeElement = select_default2(nodes[i]);
      const nodeRect = nodeElement.select(".node-rect");
      nodeElement.on("click", (event) => {
        this.handleNodeClick(event, d, nodeRect);
      });
    });
  }
  /**
   * 
   *
   * @param nodeElements D3 
   */
  attachNodeHoverHandlers(nodeElements) {
    nodeElements.each((d, i, nodes) => {
      const nodeElement = select_default2(nodes[i]);
      const nodeRect = nodeElement.select(".node-rect");
      nodeElement.on("mouseenter", (event) => {
        this.handleNodeHover(event, d, nodeRect);
      });
      nodeElement.on("mouseleave", (event) => {
        this.handleNodeLeave(event, d, nodeRect);
      });
    });
  }
  /**
   * 
   *
   * @param svg SVG 
   */
  attachCanvasDragHandlers(svg) {
    if (!this.options.enableCanvasDrag) {
      return;
    }
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    svg.on("mousedown", (event) => {
      const target = event.target;
      if (target.contentEditable === "true" || target.closest('[contenteditable="true"]')) {
        return;
      }
      if (event.button === 0 && this.isCanvasInteractionEnabled()) {
        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
        svg.style("cursor", "grabbing");
      }
    });
    svg.on("mousemove", (event) => {
      var _a, _b;
      const target = event.target;
      const isContentEditable = target.contentEditable === "true" || target.closest('[contenteditable="true"]');
      const canvasEnabled = this.isCanvasInteractionEnabled();
      if (isContentEditable) {
        return;
      }
      if (isDragging && canvasEnabled) {
        console.warn("[MouseInteraction] \u{1F6A8} CANVAS DRAG EXECUTED!", {
          target: target.tagName,
          isDragging,
          canvasEnabled,
          isContentEditable
        });
        const dx = event.clientX - dragStartX;
        const dy = event.clientY - dragStartY;
        (_b = (_a = this.callbacks).onCanvasDrag) == null ? void 0 : _b.call(_a, dx, dy);
      }
    });
    svg.on("mouseup", () => {
      if (this.isCanvasInteractionEnabled()) {
        isDragging = false;
        svg.style("cursor", "grab");
      }
    });
    svg.on("mouseleave", () => {
      if (this.isCanvasInteractionEnabled()) {
        isDragging = false;
        svg.style("cursor", "grab");
      }
    });
  }
  /**
   * 
   *
   * @param svg SVG 
   */
  attachCanvasClickHandler(svg) {
    const svgNode2 = svg.node();
    svgNode2.addEventListener("click", (event) => {
      var _a, _b, _c, _d;
      const target = event.target;
      const isNodeElement = this.isNodeElement(target);
      if (!isNodeElement) {
        this.clearSelection();
        (_b = (_a = this.callbacks).onCanvasClick) == null ? void 0 : _b.call(_a);
      }
      if (!isNodeElement) {
        this.clearSelection();
        (_d = (_c = this.callbacks).onCanvasClick) == null ? void 0 : _d.call(_c);
      }
    }, true);
  }
  /**
   * 
   */
  clearSelection() {
    if (this.selectedNode) {
      this.selectedNode.data.selected = false;
      selectAll_default2(".node-rect").classed("selected-rect", false);
      const selectedNodeElement = selectAll_default2(".nodes g").filter((d) => d === this.selectedNode);
      selectedNodeElement.select(".plus-button-group").remove();
      selectedNodeElement.select(".ai-suggest-button-group").remove();
      this.selectedNode = null;
    }
  }
  /**
   * 
   */
  getSelectedNode() {
    return this.selectedNode;
  }
  /**
   * 
   */
  destroy() {
    if (this.clickTimeout) {
      clearTimeout(this.clickTimeout);
      this.clickTimeout = null;
    }
    this.selectedNode = null;
    this.hoveredNode = null;
    this.clickNode = null;
  }
  // ==========  -  ==========
  /**
   * 
   */
  handleNodeClick(event, node, nodeRect) {
    var _a, _b;
    const currentTime = Date.now();
    const timeDiff = currentTime - this.lastClickTime;
    const isDoubleClick = timeDiff < this.options.doubleClickTimeout && this.clickNode === node;
    if (isDoubleClick) {
      this.lastClickTime = 0;
      this.clickNode = null;
      if (this.clickTimeout) {
        clearTimeout(this.clickTimeout);
        this.clickTimeout = null;
      }
      event.stopPropagation();
      (_b = (_a = this.callbacks).onNodeDoubleClick) == null ? void 0 : _b.call(_a, node, event);
      return;
    }
    this.lastClickTime = currentTime;
    this.clickNode = node;
    if (this.clickTimeout) {
      clearTimeout(this.clickTimeout);
    }
    this.performNodeSelection(node, nodeRect);
    this.clickTimeout = setTimeout(() => {
      this.lastClickTime = 0;
      this.clickNode = null;
      this.clickTimeout = null;
    }, this.options.doubleClickTimeout);
    event.stopPropagation();
  }
  /**
   * 
   */
  performNodeSelection(node, nodeRect) {
    var _a, _b, _c, _d, _e, _f;
    if ((_b = (_a = this.callbacks).isEditing) == null ? void 0 : _b.call(_a)) {
      const editingNode = (_d = (_c = this.callbacks).getEditingNode) == null ? void 0 : _d.call(_c);
      if (editingNode === node) {
        return;
      }
    }
    if (this.selectedNode && this.selectedNode !== node) {
      this.selectedNode.data.selected = false;
      selectAll_default2(".node-rect").filter((d) => d === this.selectedNode).classed("selected-rect", false);
      const previousNodeElement = selectAll_default2(".nodes g").filter((d) => d === this.selectedNode);
      previousNodeElement.select(".plus-button-group").remove();
      previousNodeElement.select(".ai-suggest-button-group").remove();
    }
    if (node.data.hovered) {
      this.clearNodeHoverState(node, nodeRect);
    }
    node.data.selected = true;
    this.selectedNode = node;
    nodeRect.classed("selected-rect", true);
    (_f = (_e = this.callbacks).onNodeSelect) == null ? void 0 : _f.call(_e, node);
  }
  /**
   * 
   */
  handleNodeHover(event, node, nodeRect) {
    var _a, _b;
    if (node.data.selected) {
      return;
    }
    if (this.hoveredNode && this.hoveredNode !== node) {
      this.clearHoverState();
    }
    this.hoveredNode = node;
    node.data.hovered = true;
    nodeRect.classed("hovered-rect", true);
    (_b = (_a = this.callbacks).onNodeHover) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  handleNodeLeave(event, node, nodeRect) {
    var _a, _b;
    if (node.data.selected) {
      return;
    }
    this.clearNodeHoverState(node, nodeRect);
    (_b = (_a = this.callbacks).onNodeLeave) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  clearNodeHoverState(node, nodeRect) {
    node.data.hovered = false;
    nodeRect.classed("hovered-rect", false);
    if (this.hoveredNode === node) {
      this.hoveredNode = null;
    }
  }
  /**
   * 
   */
  clearHoverState() {
    if (this.hoveredNode) {
      this.hoveredNode.data.hovered = false;
      selectAll_default2(".node-rect").classed("hovered-rect", false);
      this.hoveredNode = null;
    }
  }
  // ==========  ==========
  /**
   * 
   */
  isCanvasInteractionEnabled() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.callbacks).isCanvasInteractionEnabled) == null ? void 0 : _b.call(_a)) != null ? _c : true;
  }
  /**
   *  SVG 
   */
  isNodeElement(target) {
    const targetTagName = target.tagName.toLowerCase();
    const targetClasses = target.classList;
    return targetTagName === "g" && targetClasses.contains("node") || // 
    targetClasses.contains("node-rect") || // 
    targetClasses.contains("node-text-layer") || // 
    targetTagName === "foreignobject" || //  foreignObject
    targetTagName === "div" || //  div
    targetTagName === "g" && targetClasses.contains("node-group");
  }
};

// src/interactions/KeyboardManager.ts
var KeyboardManager = class {
  // ==========  ==========
  constructor(config, handlers) {
    this.config = config;
    this.handlers = handlers;
    // 
    this.keyboardListener = null;
    this.options = {
      enableShortcuts: true,
      disableMobileShortcuts: true,
      ...handlers
    };
  }
  // ==========  API ==========
  /**
   * 
   */
  attachGlobalListener() {
    this.removeGlobalKeyboardListener();
    this.keyboardListener = (event) => {
      this.handleKeyDown(event);
    };
    document.addEventListener("keydown", this.keyboardListener);
  }
  /**
   * 
   */
  removeGlobalKeyboardListener() {
    if (this.keyboardListener) {
      document.removeEventListener("keydown", this.keyboardListener);
      this.keyboardListener = null;
    }
  }
  /**
   * 
   */
  destroy() {
    this.removeGlobalKeyboardListener();
  }
  // ==========  -  ==========
  /**
   * 
   */
  handleKeyDown(event) {
    if (this.config.isActiveView && !this.config.isActiveView()) {
      return;
    }
    if (this.config.isEditing()) {
      if ((event.ctrlKey || event.metaKey) && (event.key === "c" || event.key === "x" || event.key === "v")) {
        return;
      }
      return;
    }
    if (event.key === "Tab") {
      event.preventDefault();
      this.handleTabKey();
    } else if (event.key === "Delete" || event.key === "Del") {
      event.preventDefault();
      this.handleDeleteKey();
    } else if (event.key === "Enter") {
      event.preventDefault();
      this.handleEnterKey();
    } else if (!this.isMobile() && (event.ctrlKey || event.metaKey) && event.key === "c") {
      event.preventDefault();
      this.handleCopyShortcut();
    } else if (!this.isMobile() && (event.ctrlKey || event.metaKey) && event.key === "x") {
      event.preventDefault();
      this.handleCutShortcut();
    } else if (!this.isMobile() && (event.ctrlKey || event.metaKey) && event.key === "v") {
      event.preventDefault();
      this.handlePasteShortcut();
    } else if (!this.isMobile() && (event.ctrlKey || event.metaKey) && event.key === "z" && !event.shiftKey) {
      event.preventDefault();
      this.handleUndoShortcut();
    } else if (!this.isMobile() && (event.ctrlKey || event.metaKey) && (event.key === "y" || event.key === "z" && event.shiftKey)) {
      event.preventDefault();
      this.handleRedoShortcut();
    }
  }
  /**
   * Tab - 
   */
  handleTabKey() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    (_b = (_a = this.handlers).onTab) == null ? void 0 : _b.call(_a, selectedNode);
  }
  /**
   * Delete - 
   */
  handleDeleteKey() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    (_b = (_a = this.handlers).onDelete) == null ? void 0 : _b.call(_a, selectedNode);
  }
  /**
   * Enter - 
   */
  handleEnterKey() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    if (selectedNode.data.level === 0) {
      return;
    }
    (_b = (_a = this.handlers).onEnter) == null ? void 0 : _b.call(_a, selectedNode);
  }
  /**
   *  Ctrl+C / Cmd+C  - 
   */
  handleCopyShortcut() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    void ((_b = (_a = this.handlers).onCopy) == null ? void 0 : _b.call(_a, selectedNode));
  }
  /**
   *  Ctrl+X / Cmd+X  - 
   */
  handleCutShortcut() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    void ((_b = (_a = this.handlers).onCut) == null ? void 0 : _b.call(_a, selectedNode));
  }
  /**
   *  Ctrl+V / Cmd+V  - 
   */
  handlePasteShortcut() {
    var _a, _b;
    const selectedNode = this.config.getSelectedNode();
    if (!selectedNode) {
      return;
    }
    void ((_b = (_a = this.handlers).onPaste) == null ? void 0 : _b.call(_a, selectedNode));
  }
  /**
   *  Ctrl+Z / Cmd+Z  - 
   */
  handleUndoShortcut() {
    var _a, _b;
    (_b = (_a = this.handlers).onUndo) == null ? void 0 : _b.call(_a);
  }
  /**
   *  Ctrl+Shift+Z / Cmd+Shift+Z / Ctrl+Y / Cmd+Y  - 
   */
  handleRedoShortcut() {
    var _a, _b;
    (_b = (_a = this.handlers).onRedo) == null ? void 0 : _b.call(_a);
  }
  // ==========  ==========
  /**
   * 
   */
  isMobile() {
    var _a;
    return ((_a = this.config.config) == null ? void 0 : _a.isMobile) || false;
  }
};

// src/interactions/interaction-manager.ts
var InteractionManager = class {
  constructor(config, renderCallbacks = {}, isActiveView) {
    this.config = config;
    this.renderCallbacks = renderCallbacks;
    this.isActiveView = isActiveView;
    // 
    this.state = {
      selectedNode: null,
      hoveredNode: null,
      editingState: {
        isEditing: false,
        currentNode: null,
        originalText: "",
        editElement: null
      }
    };
    const mouseCallbacks = {
      onNodeSelect: this.handleNodeSelect.bind(this),
      onNodeDoubleClick: this.handleNodeDoubleClick.bind(this),
      onNodeHover: this.handleNodeHover.bind(this),
      onNodeLeave: this.handleNodeLeave.bind(this),
      onCanvasClick: this.handleCanvasClick.bind(this),
      onCanvasDrag: this.handleCanvasDrag.bind(this),
      isCanvasInteractionEnabled: this.isCanvasInteractionEnabled.bind(this),
      isEditing: () => this.state.editingState.isEditing,
      getEditingNode: () => this.state.editingState.currentNode
    };
    this.mouseInteraction = new MouseInteraction(mouseCallbacks);
    const keyboardConfig = {
      config: this.config,
      isEditing: () => this.state.editingState.isEditing,
      getSelectedNode: () => this.state.selectedNode,
      isActiveView: this.isActiveView
    };
    const keyboardHandlers = {
      onTab: this.handleTabKey.bind(this),
      onDelete: this.handleDeleteKey.bind(this),
      onEnter: this.handleEnterKey.bind(this),
      onCopy: this.handleCopyShortcut.bind(this),
      onCut: this.handleCutShortcut.bind(this),
      onPaste: this.handlePasteShortcut.bind(this),
      onUndo: this.handleUndoShortcut.bind(this),
      onRedo: this.handleRedoShortcut.bind(this)
    };
    this.keyboardManager = new KeyboardManager(keyboardConfig, keyboardHandlers);
  }
  /**
   * 
   *
   * @param svg SVG 
   * @param nodeElements 
   */
  attachHandlers(svg, nodeElements) {
    this.mouseInteraction.attachNodeClickHandlers(nodeElements);
    this.mouseInteraction.attachNodeHoverHandlers(nodeElements);
    this.mouseInteraction.attachCanvasDragHandlers(svg);
    this.mouseInteraction.attachCanvasClickHandler(svg);
    this.keyboardManager.attachGlobalListener();
  }
  /**
   * 
   * @deprecated  getMouseInteraction()  getKeyboardManager() 
   */
  getHandler() {
    return {
      mouseInteraction: this.mouseInteraction,
      keyboardManager: this.keyboardManager
    };
  }
  /**
   * 
   */
  getMouseInteraction() {
    return this.mouseInteraction;
  }
  /**
   * 
   */
  getKeyboardManager() {
    return this.keyboardManager;
  }
  /**
   * 
   * @returns true if mobile interaction handler is active, false if desktop
   */
  isMobile() {
    return this.config.isMobile;
  }
  /**
   * 
   */
  getState() {
    return { ...this.state };
  }
  /**
   * 
   */
  selectNode(node) {
    var _a, _b;
    this.state.selectedNode = node;
    (_b = (_a = this.renderCallbacks).onNodeSelected) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  hoverNode(node) {
    var _a, _b;
    this.state.hoveredNode = node;
    (_b = (_a = this.renderCallbacks).onNodeHovered) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  clearSelection() {
    var _a, _b;
    this.state.selectedNode = null;
    this.mouseInteraction.clearSelection();
    (_b = (_a = this.renderCallbacks).onSelectionCleared) == null ? void 0 : _b.call(_a);
  }
  /**
   * 
   */
  enterEditing(node, element) {
    this.state.editingState = {
      isEditing: true,
      currentNode: node,
      originalText: node.data.text,
      editElement: element
    };
  }
  /**
   * 
   */
  exitEditing() {
    this.state.editingState = {
      isEditing: false,
      currentNode: null,
      originalText: "",
      editElement: null
    };
  }
  /**
   * 
   */
  isCanvasInteractionEnabled() {
    return !this.state.editingState.isEditing;
  }
  /**
   * 
   */
  destroy() {
    this.keyboardManager.destroy();
    this.mouseInteraction.destroy();
    this.state.selectedNode = null;
    this.state.hoveredNode = null;
    this.state.editingState = {
      isEditing: false,
      currentNode: null,
      originalText: "",
      editElement: null
    };
  }
  /**
   * 
   *  NodeEditor  InteractionManager
   *
   * RendererCoordinator  editingState 
   * InteractionManager 
   *
   * @param isEditing 
   */
  syncEditingState(isEditing) {
    this.state.editingState.isEditing = isEditing;
    if (!isEditing) {
      this.state.editingState.currentNode = null;
      this.state.editingState.originalText = "";
      this.state.editingState.editElement = null;
    }
  }
  // ==========  ==========
  /**
   * 
   */
  handleNodeSelect(node) {
    this.selectNode(node);
  }
  /**
   * 
   */
  handleNodeDoubleClick(node, event) {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onNodeDoubleClicked) == null ? void 0 : _b.call(_a, node, event);
  }
  /**
   * 
   */
  handleNodeHover(node) {
    this.hoverNode(node);
  }
  /**
   * 
   */
  handleNodeLeave(node) {
    var _a, _b;
    this.state.hoveredNode = null;
    (_b = (_a = this.renderCallbacks).onNodeLeft) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  handleCanvasClick() {
    var _a, _b;
    if (this.state.editingState.isEditing) {
      (_b = (_a = this.renderCallbacks).onExitEditMode) == null ? void 0 : _b.call(_a);
      return;
    }
    this.clearSelection();
  }
  /**
   * 
   */
  handleCanvasDrag(dx, dy) {
  }
  /**
   *  Tab 
   */
  handleTabKey(node) {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onAddChildNode) == null ? void 0 : _b.call(_a, node);
  }
  /**
   *  Delete 
   */
  handleDeleteKey(node) {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onDeleteNode) == null ? void 0 : _b.call(_a, node);
  }
  /**
   *  Enter 
   */
  handleEnterKey(node) {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onAddSiblingNode) == null ? void 0 : _b.call(_a, node);
  }
  /**
   * 
   */
  async handleCopyShortcut(node) {
    var _a, _b;
    await ((_b = (_a = this.renderCallbacks).onCopyNode) == null ? void 0 : _b.call(_a, node));
  }
  /**
   * 
   */
  async handleCutShortcut(node) {
    var _a, _b;
    await ((_b = (_a = this.renderCallbacks).onCutNode) == null ? void 0 : _b.call(_a, node));
  }
  /**
   * 
   */
  async handlePasteShortcut(node) {
    var _a, _b;
    await ((_b = (_a = this.renderCallbacks).onPasteToNode) == null ? void 0 : _b.call(_a, node));
  }
  /**
   * 
   */
  handleUndoShortcut() {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onUndo) == null ? void 0 : _b.call(_a);
  }
  /**
   * 
   */
  handleRedoShortcut() {
    var _a, _b;
    (_b = (_a = this.renderCallbacks).onRedo) == null ? void 0 : _b.call(_a);
  }
};

// src/features/AIAssistant.ts
var import_obsidian = require("obsidian");
var AIAssistant = class {
  constructor(mindMapService, messages, callbacks = {}) {
    this.mindMapService = mindMapService;
    this.messages = messages;
    this.callbacks = callbacks;
    // 
    this.selectedSuggestions = /* @__PURE__ */ new Set();
    // AI 
    this.loadingNotice = null;
  }
  /**
   *  AI 
   *
   * @param nodeElement 
   * @param node 
   * @param dimensions 
   */
  renderAIButton(nodeElement, node, dimensions) {
    const existingAIButton = nodeElement.select(".ai-suggest-button-group");
    if (!existingAIButton.empty()) {
      return;
    }
    const totalButtonsHeight = 20 + 10 + 20;
    const buttonY = (dimensions.height - totalButtonsHeight) / 2 + 20 + 10;
    const buttonX = dimensions.width + 4;
    const buttonGroup = nodeElement.append("g").attr("class", "ai-suggest-button-group").attr("transform", `translate(${buttonX}, ${buttonY})`);
    buttonGroup.on("click", (event) => {
      event.stopPropagation();
      void this.triggerSuggestions(node);
    });
    buttonGroup.append("circle").attr("class", "ai-suggest-button-bg").attr("cx", 10).attr("cy", 10).attr("r", 10).attr("fill", "#9333ea").style("opacity", 0.9).style("cursor", "pointer");
    buttonGroup.append("text").attr("class", "ai-suggest-button-text").attr("x", 10).attr("y", 10).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("fill", "white").attr("font-size", "14px").style("pointer-events", "none").text("\u2728");
    buttonGroup.append("title").text("AI Suggestions");
  }
  /**
   *  AI 
   *
   * @param nodeElement 
   */
  removeAIButton(nodeElement) {
    const buttonGroup = nodeElement.select(".ai-suggest-button-group");
    if (!buttonGroup.empty()) {
      buttonGroup.remove();
    }
  }
  /**
   *  AI 
   *
   * @param node 
   */
  async triggerSuggestions(node) {
    var _a;
    if (!this.mindMapService) {
      new import_obsidian.Notice(this.messages.errors.serviceNotAvailable);
      return;
    }
    const nodeText = ((_a = node.data.text) == null ? void 0 : _a.trim()) || "";
    if (!nodeText) {
      new import_obsidian.Notice(this.messages.errors.emptyNodeError);
      return;
    }
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = null;
    }
    this.loadingNotice = new import_obsidian.Notice(this.messages.format(
      this.messages.notices.aiAnalyzing,
      { nodeText }
    ), 0);
    try {
      const suggestions = await this.mindMapService.suggestChildNodes(node.data);
      if (this.loadingNotice) {
        this.loadingNotice.hide();
        this.loadingNotice = null;
      }
      if (suggestions.length === 0) {
        new import_obsidian.Notice(this.messages.notices.aiNoSuggestions);
        return;
      }
      this.showSuggestionsPanel(node, suggestions);
    } catch (error) {
      if (this.loadingNotice) {
        this.loadingNotice.hide();
        this.loadingNotice = null;
      }
      const errorMsg = this.messages.format(
        this.messages.notices.aiFailed,
        { error: error.message }
      );
      new import_obsidian.Notice(errorMsg);
    }
  }
  /**
   * 
   *
   * @param node 
   * @param suggestions 
   */
  showSuggestionsPanel(node, suggestions) {
    this.hideSuggestionsPanel();
    const panel = document.createElement("div");
    panel.className = "ai-suggestions-panel";
    const header = document.createElement("div");
    header.className = "ai-suggestions-header";
    const title = document.createElement("h4");
    title.textContent = this.messages.ui.aiSuggestionsTitle;
    const actionButtons = document.createElement("div");
    actionButtons.className = "ai-suggestions-actions";
    const selectAllBtn = document.createElement("button");
    selectAllBtn.className = "ai-suggestions-select-all";
    selectAllBtn.textContent = this.messages.ui.aiAddAll;
    selectAllBtn.title = this.messages.ui.aiAddAllTooltip;
    selectAllBtn.onclick = () => {
      suggestions.forEach((suggestion) => {
        if (!this.selectedSuggestions.has(suggestion)) {
          const listItem = Array.from(list.children).find(
            (item) => {
              var _a;
              return (_a = item.textContent) == null ? void 0 : _a.includes(suggestion);
            }
          );
          this.createChildFromSuggestion(node, suggestion, listItem);
        }
      });
    };
    const closeBtn = document.createElement("button");
    closeBtn.className = "ai-suggestions-close";
    closeBtn.textContent = this.messages.ui.aiClose;
    closeBtn.onclick = () => this.hideSuggestionsPanel();
    actionButtons.appendChild(selectAllBtn);
    actionButtons.appendChild(closeBtn);
    header.appendChild(title);
    header.appendChild(actionButtons);
    panel.appendChild(header);
    const list = document.createElement("ul");
    list.className = "ai-suggestions-list";
    suggestions.forEach((suggestion) => {
      const item = document.createElement("li");
      item.className = "ai-suggestion-item";
      const isSelected = this.selectedSuggestions.has(suggestion);
      if (isSelected) {
        item.classList.add("ai-suggestion-item-selected");
      }
      const checkmark = document.createElement("span");
      checkmark.className = "ai-suggestion-checkmark";
      checkmark.textContent = isSelected ? "\u2713" : "";
      const text = document.createElement("span");
      text.className = "ai-suggestion-text";
      text.textContent = suggestion;
      item.appendChild(checkmark);
      item.appendChild(text);
      item.onclick = () => {
        if (!this.selectedSuggestions.has(suggestion)) {
          this.createChildFromSuggestion(node, suggestion, item);
        } else {
          new import_obsidian.Notice(this.messages.format(
            this.messages.notices.alreadyAdded || `Already added: {nodeText}`,
            { nodeText: suggestion }
          ));
        }
      };
      list.appendChild(item);
    });
    panel.appendChild(list);
    document.body.appendChild(panel);
  }
  /**
   * 
   */
  hideSuggestionsPanel() {
    const panel = document.querySelector(".ai-suggestions-panel");
    if (panel) {
      panel.remove();
    }
  }
  /**
   * 
   *
   * @param parentNode 
   * @param suggestion 
   * @param listItemElement UI
   */
  createChildFromSuggestion(parentNode, suggestion, listItemElement) {
    var _a, _b;
    if (this.selectedSuggestions.has(suggestion)) {
      new import_obsidian.Notice(this.messages.format(
        this.messages.notices.alreadyAdded || `Already added: {nodeText}`,
        { nodeText: suggestion }
      ));
      return;
    }
    try {
      this.mindMapService.createChildNode(parentNode.data, suggestion);
      this.selectedSuggestions.add(suggestion);
      (_b = (_a = this.callbacks).onNodeCreated) == null ? void 0 : _b.call(_a);
      if (listItemElement) {
        listItemElement.classList.add("ai-suggestion-item-selected");
        const checkmark = listItemElement.querySelector(".ai-suggestion-checkmark");
        if (checkmark) {
          checkmark.textContent = "\u2713";
        }
      }
      new import_obsidian.Notice(this.messages.format(
        this.messages.notices.nodeCreated || `Created: {nodeText}`,
        { nodeText: suggestion }
      ));
    } catch (error) {
      new import_obsidian.Notice(this.messages.format(
        this.messages.notices.nodeCreateFailed || `Failed to create node: {error}`,
        { error: error.message }
      ));
    }
  }
  /**
   * 
   *
   *  mind map 
   */
  clearSelectedSuggestions() {
    this.selectedSuggestions.clear();
  }
  /**
   *  AI Assistant
   *
   * 
   */
  destroy() {
    this.hideSuggestionsPanel();
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = null;
    }
    this.selectedSuggestions.clear();
  }
};

// src/features/NodeEditor.ts
var import_obsidian2 = require("obsidian");
var NodeEditor = class {
  constructor(config, messages, callbacks = {}, editingState) {
    this.config = config;
    this.messages = messages;
    this.callbacks = callbacks;
    // 
    this.canvasInteractionEnabled = true;
    this.editingState = editingState || {
      isEditing: false,
      currentNode: null,
      originalText: "",
      editElement: null
    };
  }
  /**
   * 
   *
   * @param node 
   * @param editElement 
   */
  enableEditing(node, editElement) {
    if (node.depth === 0) {
      this.showRootNodeEditWarning();
      return;
    }
    if (this.editingState.isEditing && this.editingState.currentNode !== node) {
      this.exitEditMode();
    }
    this.setCanvasInteraction(false);
    this.editingState.isEditing = true;
    this.editingState.currentNode = node;
    this.editingState.originalText = node.data.text;
    this.editingState.editElement = editElement;
    try {
      editElement.contentEditable = "true";
      editElement.classList.add("editing");
      const nodeElement = select_default2(editElement.closest("g"));
      nodeElement.classed("node-editing", true);
      setTimeout(() => {
        try {
          editElement.focus();
          const range = document.createRange();
          range.selectNodeContents(editElement);
          const selection2 = window.getSelection();
          if (selection2) {
            selection2.removeAllRanges();
            selection2.addRange(range);
          }
        } catch (focusError) {
          this.showValidationError(this.messages.errors.focusSetFailed);
          this.exitEditMode();
        }
      }, 10);
      setTimeout(() => {
        this.showEditingHint();
      }, 100);
    } catch (error) {
      this.showValidationError(this.messages.errors.enterEditModeFailed);
      this.exitEditMode();
    }
  }
  /**
   * 
   */
  exitEditMode() {
    if (!this.editingState.isEditing) return;
    const { editElement, currentNode } = this.editingState;
    this.setCanvasInteraction(true);
    if (editElement) {
      try {
        editElement.contentEditable = "false";
        editElement.classList.remove("editing");
        const selection2 = window.getSelection();
        if (selection2) {
          selection2.removeAllRanges();
        }
        const nodeElement = select_default2(editElement.closest("g"));
        nodeElement.classed("node-editing", false);
      } catch (error) {
      }
    }
    this.hideEditingHint();
    this.editingState.isEditing = false;
    this.editingState.currentNode = null;
    this.editingState.originalText = "";
    this.editingState.editElement = null;
  }
  /**
   * 
   */
  cancelEdit() {
    if (!this.editingState.isEditing) return;
    const { editElement } = this.editingState;
    if (editElement && this.editingState.originalText) {
      editElement.textContent = this.editingState.originalText;
    }
    this.exitEditMode();
  }
  /**
   * 
   */
  saveText() {
    var _a, _b, _c, _d, _e;
    if (!this.editingState.isEditing || !this.editingState.currentNode || !this.editingState.editElement) {
      return;
    }
    const { editElement, currentNode } = this.editingState;
    const newText = ((_a = editElement.textContent) == null ? void 0 : _a.trim()) || "";
    try {
      if (!this.validateText(newText)) {
        this.showValidationError(this.messages.errors.nodeTextEmpty);
        return;
      }
      if (newText === this.editingState.originalText) {
        this.exitEditMode();
        return;
      }
      (_c = (_b = this.callbacks).onBeforeTextChange) == null ? void 0 : _c.call(_b, currentNode);
      currentNode.data.text = newText;
      (_e = (_d = this.callbacks).onTextChanged) == null ? void 0 : _e.call(_d, currentNode, newText);
    } catch (error) {
      this.showValidationError(this.messages.errors.saveFailed);
      editElement.textContent = this.editingState.originalText;
    }
    this.exitEditMode();
  }
  /**
   * 
   *
   * @param text 
   * @returns 
   */
  validateText(text) {
    if (!text || text.trim().length === 0) {
      return false;
    }
    if (text.length > VALIDATION_CONSTANTS.MAX_TEXT_LENGTH) {
      return false;
    }
    const invalidChars = VALIDATION_CONSTANTS.INVALID_CHARACTERS;
    if (invalidChars.some((char) => text.includes(char))) {
      return false;
    }
    return true;
  }
  /**
   * 
   *  TextRenderer 
   */
  getEditingState() {
    return this.editingState;
  }
  /**
   * 
   */
  isEditing() {
    return this.editingState.isEditing;
  }
  /**
   * 
   */
  isCanvasInteractionEnabled() {
    return this.canvasInteractionEnabled;
  }
  /**
   * 
   */
  destroy() {
    this.exitEditMode();
    this.hideEditingHint();
  }
  // ==========  ==========
  /**
   * 
   */
  setCanvasInteraction(enabled) {
    var _a, _b;
    this.canvasInteractionEnabled = enabled;
    (_b = (_a = this.callbacks).onCanvasInteractionChanged) == null ? void 0 : _b.call(_a, enabled);
  }
  /**
   * 
   */
  showEditingHint() {
    let hintElement = document.querySelector(".editing-hint");
    if (!hintElement) {
      hintElement = document.createElement("div");
      hintElement.className = "editing-hint";
      const editHint = this.config.isMobile ? this.messages.ui.editHintMobile : this.messages.ui.editHintDesktop;
      hintElement.textContent = editHint;
      document.body.appendChild(hintElement);
    }
    hintElement.classList.add("show");
  }
  /**
   * 
   */
  hideEditingHint() {
    const hintElement = document.querySelector(".editing-hint");
    if (hintElement) {
      hintElement.classList.remove("show");
    }
  }
  /**
   * 
   */
  showRootNodeEditWarning() {
    new import_obsidian2.Notice(this.messages.validation.cannotEditRoot, 3e3);
  }
  /**
   * 
   */
  showValidationError(message) {
    const errorElement = document.createElement("div");
    errorElement.className = "mind-map-validation-error";
    errorElement.textContent = message;
    document.body.appendChild(errorElement);
    setTimeout(() => {
      errorElement.classList.add("fading-out");
      setTimeout(() => {
        if (errorElement.parentNode) {
          errorElement.parentNode.removeChild(errorElement);
        }
      }, 200);
    }, 3e3);
    if (this.editingState.isEditing) {
      try {
        this.exitEditMode();
      } catch (recoveryError) {
      }
    }
  }
};

// src/features/ClipboardManager.ts
var import_obsidian3 = require("obsidian");
function setCssProps2(element, props) {
  Object.assign(element.style, props);
}
var ClipboardManager = class {
  constructor(mindMapService, messages, callbacks = {}) {
    this.mindMapService = mindMapService;
    this.messages = messages;
    this.callbacks = callbacks;
  }
  /**
   *  markdown 
   *
   * @param node 
   * @returns Promise<boolean> 
   */
  async copyNode(node) {
    try {
      const markdown = this.mindMapService.serializeSubtreeToMarkdown(node.data);
      if (navigator.clipboard && window.isSecureContext) {
        try {
          await navigator.clipboard.writeText(markdown);
          this.showSuccessNotice(this.messages.notices.nodeTextCopied);
          return true;
        } catch (e) {
          return this.fallbackCopy(markdown);
        }
      } else {
        return this.fallbackCopy(markdown);
      }
    } catch (error) {
      this.showErrorNotice(this.messages.notices.copyFailed);
      return false;
    }
  }
  /**
   * +
   *
   * @param node 
   * @returns Promise<boolean> 
   */
  async cutNode(node) {
    var _a, _b, _c, _d;
    const copySuccess = await this.copyNode(node);
    if (copySuccess) {
      const deleteSuccess = this.mindMapService.deleteNode(node.data);
      if (deleteSuccess) {
        (_b = (_a = this.callbacks).clearSelection) == null ? void 0 : _b.call(_a);
        (_d = (_c = this.callbacks).onDataUpdated) == null ? void 0 : _d.call(_c);
        return true;
      }
    }
    return false;
  }
  /**
   * 
   *
   * @param node 
   * @returns Promise<boolean> 
   */
  async pasteToNode(node) {
    try {
      if (!navigator.clipboard || !window.isSecureContext) {
        return false;
      }
      const clipboardText = await navigator.clipboard.readText();
      if (!clipboardText || clipboardText.trim().length === 0) {
        return false;
      }
      const isMarkdownFormat = /^\s*[-*]/m.test(clipboardText);
      if (isMarkdownFormat) {
        return this.pasteSubtree(node, clipboardText);
      } else {
        return this.pasteText(node, clipboardText);
      }
    } catch (e) {
      return false;
    }
  }
  /**
   * 
   */
  destroy() {
  }
  // ==========  ==========
  /**
   * 
   *
   * Note: This uses the deprecated execCommand as a fallback for older browsers
   * that don't support the modern Clipboard API. The modern API is tried first
   * in copyNode(). This fallback is only used when:
   * - navigator.clipboard is not available (older browsers)
   * - window.isSecureContext is false (non-HTTPS contexts)
   * - The Clipboard API call throws an error
   */
  fallbackCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    setCssProps2(textArea, {
      position: "fixed",
      top: "0",
      left: "0",
      width: "2em",
      height: "2em",
      padding: "0",
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent",
      opacity: "0",
      pointerEvents: "none"
    });
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      const successful = document.execCommand("copy");
      if (successful) {
        this.showSuccessNotice(this.messages.notices.nodeTextCopied);
        return true;
      } else {
        this.showErrorNotice(this.messages.notices.copyFailed);
        return false;
      }
    } catch (err) {
      this.showErrorNotice(this.messages.notices.copyFailed);
      return false;
    } finally {
      document.body.removeChild(textArea);
    }
  }
  /**
   * markdown 
   */
  pasteSubtree(node, clipboardText) {
    var _a, _b, _c, _d;
    const subtreeRoot = this.mindMapService.createSubtreeFromMarkdown(
      clipboardText,
      node.data.level
    );
    if (subtreeRoot) {
      subtreeRoot.parent = node.data;
      node.data.children.push(subtreeRoot);
      (_b = (_a = this.callbacks).clearSelection) == null ? void 0 : _b.call(_a);
      subtreeRoot.selected = true;
      (_d = (_c = this.callbacks).onDataUpdated) == null ? void 0 : _d.call(_c);
      return true;
    } else {
      return this.pasteText(node, clipboardText);
    }
  }
  /**
   * 
   */
  pasteText(node, clipboardText) {
    var _a, _b, _c, _d;
    const truncatedText = clipboardText.substring(0, VALIDATION_CONSTANTS.MAX_TEXT_LENGTH);
    const childNode = this.mindMapService.createChildNode(node.data, truncatedText);
    (_b = (_a = this.callbacks).clearSelection) == null ? void 0 : _b.call(_a);
    childNode.selected = true;
    (_d = (_c = this.callbacks).onDataUpdated) == null ? void 0 : _d.call(_c);
    return true;
  }
  /**
   * 
   */
  showSuccessNotice(message) {
    new import_obsidian3.Notice(message, 2e3);
  }
  /**
   * 
   */
  showErrorNotice(message) {
    new import_obsidian3.Notice(message, 3e3);
  }
};

// src/features/ButtonRenderer.ts
var ButtonRenderer = class {
  constructor(mindMapService, textMeasurer, callbacks = {}) {
    this.mindMapService = mindMapService;
    this.textMeasurer = textMeasurer;
    this.callbacks = callbacks;
  }
  /**
   * +
   *
   * @param nodeElements D3 
   */
  renderButtons(nodeElements) {
    const nodes = nodeElements.nodes();
    const data = nodeElements.data();
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const d = data[i];
      const nodeElement = select_default2(node);
      const dimensions = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);
      if (d.data.selected) {
        this.renderPlusButton(nodeElement, d, dimensions);
      }
    }
  }
  /**
   * +
   *
   * @param nodeElement 
   * @param node 
   * @param dimensions 
   */
  renderPlusButton(nodeElement, node, dimensions) {
    const existingButton = nodeElement.select(".plus-button-group");
    if (!existingButton.empty()) {
      return;
    }
    const totalButtonsHeight = 20 + 10 + 20;
    const buttonY = (dimensions.height - totalButtonsHeight) / 2;
    const buttonGroup = nodeElement.append("g").attr("class", "plus-button-group").attr("transform", `translate(${dimensions.width + 4}, ${buttonY})`);
    buttonGroup.on("click", (event) => {
      this.handleButtonClick(event, node);
    });
    buttonGroup.append("circle").attr("class", "plus-button-bg").attr("cx", 10).attr("cy", 10).attr("r", 10).attr("fill", "#2972f4").style("opacity", 0.9).style("cursor", "pointer");
    buttonGroup.append("text").attr("class", "plus-button-text").attr("x", 10).attr("y", 10).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("fill", "white").attr("font-size", "16px").attr("font-weight", "bold").style("pointer-events", "none").text("+");
  }
  /**
   * +
   *
   * @param nodeElement 
   */
  removePlusButton(nodeElement) {
    const buttonGroup = nodeElement.select(".plus-button-group");
    if (!buttonGroup.empty()) {
      buttonGroup.remove();
    }
  }
  /**
   * 
   */
  destroy() {
  }
  // ==========  ==========
  /**
   * +
   */
  handleButtonClick(event, node) {
    var _a, _b;
    event.stopPropagation();
    (_b = (_a = this.callbacks).onAddChildNode) == null ? void 0 : _b.call(_a, node);
  }
};

// src/features/MobileToolbar.ts
var MobileToolbar = class {
  constructor(textMeasurer, messages, callbacks = {}) {
    this.textMeasurer = textMeasurer;
    this.messages = messages;
    this.callbacks = callbacks;
    this.toolbar = null;
    this.currentNode = null;
  }
  /**
   * 
   *
   * @param svg SVG 
   */
  create(svg) {
    if (this.toolbar) {
      this.toolbar.remove();
      this.toolbar = null;
    }
    const content = svg.select(".mindmap-content");
    if (content.empty()) {
      return;
    }
    const toolbarGroup = content.append("g").attr("class", "shared-node-toolbar").style("display", "none");
    this.createToolbarContent(toolbarGroup);
    this.toolbar = toolbarGroup;
  }
  /**
   * 
   *
   * @param node 
   * @param offsetX X
   * @param offsetY Y
   */
  updatePosition(node, offsetX, offsetY) {
    if (!this.toolbar) {
      return;
    }
    const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);
    const nodeCanvasX = node.y + offsetX;
    const nodeCanvasY = node.x + offsetY - dimensions.height / 2;
    const toolbarWidth = 320;
    const toolbarHeight = 44;
    const toolbarOffsetX = (dimensions.width - toolbarWidth) / 2;
    const toolbarOffsetY = -toolbarHeight - 12;
    const toolbarX = nodeCanvasX + toolbarOffsetX;
    const toolbarY = nodeCanvasY + toolbarOffsetY;
    this.toolbar.interrupt().attr("transform", `translate(${toolbarX}, ${toolbarY})`).style("display", "block").style("opacity", 0);
    this.currentNode = node;
    this.attachHandlers(node);
    requestAnimationFrame(() => {
      if (this.toolbar) {
        this.toolbar.style("transition", "opacity 0.15s ease-out").style("opacity", 1);
      }
    });
  }
  /**
   * 
   */
  hide() {
    if (!this.toolbar) {
      return;
    }
    this.toolbar.style("opacity", 0).transition().duration(150).on("end", () => {
      var _a;
      (_a = this.toolbar) == null ? void 0 : _a.style("display", "none");
      this.currentNode = null;
    });
  }
  /**
   * 
   */
  destroy() {
    if (this.toolbar) {
      this.toolbar.remove();
      this.toolbar = null;
    }
    this.currentNode = null;
  }
  // ==========  ==========
  /**
   * 
   */
  createToolbarContent(toolbarGroup) {
    const toolbarWidth = 400;
    const toolbarHeight = 44;
    toolbarGroup.append("rect").attr("class", "toolbar-bg").attr("width", toolbarWidth).attr("height", toolbarHeight).attr("rx", 8).attr("ry", 8).attr("fill", "#000000");
    toolbarGroup.append("path").attr("class", "toolbar-arrow").attr("d", "M 200 52 L 192 44 L 208 44 Z").attr("fill", "#000000");
    for (let i = 1; i <= 3; i++) {
      toolbarGroup.append("line").attr("class", "toolbar-separator").attr("x1", toolbarWidth / 4 * i).attr("y1", 8).attr("x2", toolbarWidth / 4 * i).attr("y2", toolbarHeight - 8).attr("stroke", "#333333").attr("stroke-width", 1);
    }
    this.createToolbarButton(toolbarGroup, 0, toolbarWidth, toolbarHeight, "edit");
    this.createToolbarButton(toolbarGroup, 1, toolbarWidth, toolbarHeight, "copy");
    this.createToolbarButton(toolbarGroup, 2, toolbarWidth, toolbarHeight, "paste");
    this.createToolbarButton(toolbarGroup, 3, toolbarWidth, toolbarHeight, "delete");
  }
  /**
   * 
   */
  createToolbarButton(toolbarGroup, index, toolbarWidth, toolbarHeight, type2) {
    const buttonGroup = toolbarGroup.append("g").attr("class", `toolbar-btn ${type2}-btn`).style("cursor", "pointer");
    buttonGroup.append("rect").attr("x", toolbarWidth / 4 * index).attr("width", toolbarWidth / 4).attr("height", toolbarHeight).attr("fill", "transparent").attr("rx", 8).attr("ry", 8);
    const buttonConfig = {
      edit: { icon: "\u270F\uFE0F", text: this.messages.ui.contextEdit },
      copy: { icon: "\u{1F4CB}", text: this.messages.ui.contextCopy },
      paste: { icon: "\u{1F4D1}", text: this.messages.ui.contextPaste },
      delete: { icon: "\u{1F5D1}\uFE0F", text: this.messages.ui.contextDelete }
    };
    const config = buttonConfig[type2];
    const buttonCenterX = toolbarWidth / 4 * index + toolbarWidth / 8;
    buttonGroup.append("text").attr("x", buttonCenterX - 16).attr("y", toolbarHeight / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("fill", "#ffffff").attr("font-size", "14px").style("pointer-events", "none").text(config.icon);
    buttonGroup.append("text").attr("x", buttonCenterX + 16).attr("y", toolbarHeight / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("fill", "#ffffff").attr("font-size", "14px").attr("font-weight", "500").style("pointer-events", "none").text(config.text);
  }
  /**
   * 
   */
  attachHandlers(node) {
    if (!this.toolbar) return;
    this.toolbar.select(".edit-btn").on("click", (event) => {
      this.handleButtonClick(event, node, "edit");
    });
    this.toolbar.select(".copy-btn").on("click", (event) => {
      this.handleButtonClick(event, node, "copy");
    });
    this.toolbar.select(".paste-btn").on("click", (event) => {
      this.handleButtonClick(event, node, "paste");
    });
    this.toolbar.select(".delete-btn").on("click", (event) => {
      this.handleButtonClick(event, node, "delete");
    });
  }
  /**
   * 
   */
  handleButtonClick(event, node, type2) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    event.stopPropagation();
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
    switch (type2) {
      case "edit":
        (_b = (_a = this.callbacks).onEdit) == null ? void 0 : _b.call(_a, node);
        break;
      case "copy":
        (_d = (_c = this.callbacks).onCopy) == null ? void 0 : _d.call(_c, node);
        break;
      case "paste":
        (_f = (_e = this.callbacks).onPaste) == null ? void 0 : _f.call(_e, node);
        break;
      case "delete":
        (_h = (_g = this.callbacks).onDelete) == null ? void 0 : _h.call(_g, node);
        break;
    }
  }
};

// src/renderers/renderer-coordinator.ts
var RendererCoordinator = class {
  constructor(mindMapService, config, messages, isActiveView) {
    this.mindMapService = mindMapService;
    this.isActiveView = isActiveView;
    // ==========  ==========
    this.currentSvg = null;
    this.currentContent = null;
    this.currentZoom = null;
    this.currentZoomTransform = identity2;
    this.currentData = null;
    // 
    this.isRendering = false;
    this.pendingRenderRequest = false;
    // 
    this.selectedNode = null;
    this.hoveredNode = null;
    // 
    this.editingState = {
      isEditing: false,
      currentNode: null,
      originalText: "",
      editElement: null
    };
    // 
    this.canvasInteractionEnabled = true;
    // 
    this.layoutConfig = {
      minNodeGap: 25,
      lineOffset: 6,
      horizontalSpacing: 170,
      verticalSpacing: 110,
      minVerticalGap: 25,
      treeHeight: 800,
      treeWidth: 1200,
      nodeHeightBuffer: 15
    };
    this.config = config || { isMobile: false };
    this.messages = messages || {};
    if (!messages) {
    }
    this.undoManager = new UndoManager();
    this.initializeCoreRenderers();
    this.initializeFeatureModules();
  }
  // ==========  ==========
  initializeCoreRenderers() {
    this.textMeasurer = new TextMeasurer();
    this.layoutCalculator = new LayoutCalculator();
    this.nodeRenderer = new NodeRenderer(this.textMeasurer, this.layoutCalculator);
    this.linkRenderer = new LinkRenderer(this.textMeasurer, { lineOffset: this.layoutConfig.lineOffset });
    this.textRenderer = new TextRenderer(this.textMeasurer, this.config, this.editingState);
  }
  initializeFeatureModules() {
    const renderCallbacks = {
      onNodeSelected: (node) => this.handleNodeSelected(node),
      onNodeHovered: (node) => this.handleNodeHovered(node),
      onNodeLeft: (node) => this.handleNodeLeft(node),
      onSelectionCleared: () => this.handleSelectionCleared(),
      onNodeDoubleClicked: (node, event) => this.handleNodeDoubleClicked(node, event),
      onAddChildNode: (node) => this.handleAddChildNode(node),
      onAddSiblingNode: (node) => this.handleAddSiblingNode(node),
      onDeleteNode: (node) => this.handleDeleteNode(node),
      onCopyNode: (node) => this.handleCopyNode(node),
      onCutNode: (node) => this.handleCutNode(node),
      onPasteToNode: (node) => this.handlePasteToNode(node),
      onExitEditMode: () => this.handleExitEditMode(),
      onUndo: () => this.undo(),
      onRedo: () => this.redo()
    };
    this.interactionManager = new InteractionManager(this.config, renderCallbacks, this.isActiveView);
    const aiCallbacks = {
      onNodeCreated: () => this.triggerDataUpdate()
    };
    this.aiAssistant = new AIAssistant(this.mindMapService, this.messages, aiCallbacks);
    const editorCallbacks = {
      onBeforeTextChange: (node) => {
        if (this.currentData) {
          this.undoManager.saveSnapshot(this.currentData);
        }
      },
      onTextChanged: (node, newText) => {
        var _a;
        (_a = this.onTextChanged) == null ? void 0 : _a.call(this, node, newText);
      },
      onCanvasInteractionChanged: (enabled) => {
        this.canvasInteractionEnabled = enabled;
        this.interactionManager.syncEditingState(!enabled);
      }
    };
    this.nodeEditor = new NodeEditor(this.config, this.messages, editorCallbacks, this.editingState);
    const clipboardCallbacks = {
      onDataUpdated: () => this.triggerDataUpdate(),
      clearSelection: () => this.clearSelection()
    };
    this.clipboardManager = new ClipboardManager(this.mindMapService, this.messages, clipboardCallbacks);
    const buttonCallbacks = {
      onAddChildNode: (node) => this.handleAddChildNode(node),
      enterEditMode: (node) => this.enterEditModeForNode(node),
      clearSelection: () => this.clearSelection(),
      selectNode: (node) => this.selectNode(node),
      onDataUpdated: () => this.triggerDataUpdate()
    };
    this.buttonRenderer = new ButtonRenderer(
      this.mindMapService,
      this.textMeasurer,
      buttonCallbacks
    );
    if (this.config.isMobile) {
      const toolbarCallbacks = {
        onEdit: (node) => this.enterEditModeForNode(node),
        onCopy: async (node) => {
          await this.clipboardManager.copyNode(node);
        },
        onPaste: async (node) => {
          await this.clipboardManager.pasteToNode(node);
        },
        onDelete: (node) => this.handleDeleteNode(node)
      };
      this.mobileToolbar = new MobileToolbar(
        this.textMeasurer,
        this.messages,
        toolbarCallbacks
      );
    }
  }
  // ========== MindMapRenderer  ==========
  render(container, data) {
    if (this.isRendering) {
      this.pendingRenderRequest = true;
      return;
    }
    this.isRendering = true;
    this.currentData = data;
    this.validateSelectionState();
    let root2;
    try {
      select_default2(container).selectAll("*").remove();
      const svg = select_default2(container).append("svg").attr("width", "100%").attr("height", "100%").style("position", "relative");
      this.currentSvg = svg;
      this.currentContent = svg.append("g").attr("class", "mindmap-content");
      root2 = hierarchy(data.rootNode);
      const dynamicTreeHeight = this.calculateDynamicTreeHeight(root2);
      this.layoutCalculator.updateConfig({
        treeHeight: dynamicTreeHeight
      });
      this.layoutCalculator.createCustomTreeLayout(
        root2,
        (depth, text) => this.textMeasurer.getNodeDimensions(depth, text)
      );
      this.createGradientDefinitions(svg);
      this.setupZoom(svg, container);
      if (this.currentZoomTransform) {
        svg.call(this.currentZoom.transform, this.currentZoomTransform);
        this.currentContent.attr("transform", this.currentZoomTransform);
      }
      const offsetX = 0;
      const offsetY = 0;
      this.renderLinks(root2, offsetX, offsetY);
      this.renderNodes(root2, offsetX, offsetY);
      this.restoreViewState();
      this.applyInitialViewPosition(root2, svg, this.currentZoom, container);
    } finally {
      this.isRendering = false;
      if (this.pendingRenderRequest) {
        this.pendingRenderRequest = false;
        setTimeout(() => {
          this.render(container, data);
        }, 16);
      }
      this.syncSelectedNodeReference(root2);
      if (this.config.isMobile && this.mobileToolbar) {
        this.mobileToolbar.create(this.currentSvg);
      }
      this.restoreSelectionUI();
    }
  }
  destroy() {
    var _a;
    (_a = this.mobileToolbar) == null ? void 0 : _a.destroy();
    this.buttonRenderer.destroy();
    this.clipboardManager.destroy();
    this.nodeEditor.destroy();
    this.aiAssistant.destroy();
    this.interactionManager.destroy();
    if (this.currentSvg) {
      this.currentSvg.selectAll("*").remove();
      this.currentSvg = null;
    }
    this.currentContent = null;
  }
  // ========== ==========
  /**
   * 
   *  render() 
   */
  saveViewState() {
    if (this.currentSvg && this.currentZoom) {
      const svgNode2 = this.currentSvg.node();
      if (svgNode2) {
        this.currentZoomTransform = transform(svgNode2);
      }
    }
  }
  /**
   * 
   *  NodeEditor 
   */
  exitEditMode() {
    if (this.nodeEditor.isEditing()) {
      this.nodeEditor.exitEditMode();
    }
  }
  /**
   * 
   *  TextRenderer 
   *  Enter 
   */
  saveNodeText() {
    if (this.nodeEditor.isEditing()) {
      this.nodeEditor.saveText();
    }
  }
  /**
   * 
   *  TextRenderer 
   *  Escape 
   */
  cancelEditMode() {
    if (this.nodeEditor.isEditing()) {
      this.nodeEditor.cancelEdit();
    }
  }
  // ==========  ==========
  renderLinks(root2, offsetX, offsetY) {
    this.linkRenderer.renderLinks(this.currentContent, root2.links(), offsetX, offsetY);
  }
  renderNodes(root2, offsetX, offsetY) {
    const nodeElements = this.nodeRenderer.renderNodes(this.currentContent, root2.descendants(), offsetX, offsetY);
    this.textRenderer.renderText(nodeElements, void 0, this);
    this.attachInteractionHandlers(nodeElements);
  }
  setupZoom(svg, container) {
    this.currentZoom = zoom_default2().scaleExtent([0.1, 4]).filter((event) => {
      if (!this.canvasInteractionEnabled) {
        return false;
      }
      const target = event.target;
      if (target.contentEditable === "true" || target.closest('[contenteditable="true"]')) {
        return false;
      }
      return true;
    }).on("zoom", (event) => {
      this.handleZoom(event);
    });
    svg.call(this.currentZoom);
    svg.on("dblclick.zoom", null);
  }
  applyInitialViewPosition(root2, svg, zoom, container) {
    if (this.currentZoomTransform) {
      return;
    }
    requestAnimationFrame(() => {
      const containerWidth = container.clientWidth || 1600;
      const containerHeight = container.clientHeight || 1e3;
      const initialTransform = identity2.translate(20, (containerHeight - 100) / 2).scale(1);
      svg.call(zoom.transform, initialTransform);
    });
  }
  attachInteractionHandlers(nodeElements) {
    this.interactionManager.attachHandlers(this.currentSvg, nodeElements);
    if (this.config.isMobile && this.mobileToolbar) {
      this.mobileToolbar.create(this.currentSvg);
    }
  }
  // ==========  ==========
  handleZoom(event) {
    if (this.currentContent) {
      this.currentContent.attr("transform", event.transform);
    }
    this.currentZoomTransform = event.transform;
  }
  // ========== RenderCallbacks  ==========
  handleNodeSelected(node) {
    this.selectedNode = node;
    const nodeElement = selectAll_default2(".nodes g").filter((d) => d === node);
    const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);
    this.buttonRenderer.renderPlusButton(nodeElement, node, dimensions);
    this.aiAssistant.renderAIButton(nodeElement, node, dimensions);
    if (this.config.isMobile && this.mobileToolbar && !this.nodeEditor.isEditing()) {
      this.mobileToolbar.updatePosition(node, 0, 0);
    }
  }
  handleNodeHovered(node) {
    this.hoveredNode = node;
  }
  handleNodeLeft(node) {
    if (this.hoveredNode === node) {
      this.hoveredNode = null;
    }
  }
  handleSelectionCleared() {
    this.selectedNode = null;
    if (this.config.isMobile && this.mobileToolbar) {
      this.mobileToolbar.hide();
    }
  }
  handleNodeDoubleClicked(node, event) {
    const targetElement = selectAll_default2(".nodes g").filter((d) => d === node).select(".node-unified-text").node();
    if (targetElement) {
      this.nodeEditor.enableEditing(node, targetElement);
    }
  }
  handleAddChildNode(node) {
    if (this.currentData) {
      this.undoManager.saveSnapshot(this.currentData);
    }
    const newNode = this.mindMapService.createChildNode(node.data, "New Node");
    this.clearSelection();
    newNode.selected = true;
    this.selectedNode = {
      data: newNode,
      depth: newNode.level,
      parent: node,
      children: []
    };
    this.triggerDataUpdate();
    setTimeout(() => {
      this.editNewNode();
    }, 150);
  }
  handleAddSiblingNode(node) {
    if (this.currentData) {
      this.undoManager.saveSnapshot(this.currentData);
    }
    const parentNode = node.parent;
    const newNode = this.mindMapService.createSiblingNode(
      node.data,
      "New Node"
    );
    if (!newNode) return;
    this.clearSelection();
    newNode.selected = true;
    this.selectedNode = {
      data: newNode,
      depth: newNode.level,
      parent: parentNode,
      children: []
    };
    this.triggerDataUpdate();
    setTimeout(() => {
      this.editNewNode();
    }, 150);
  }
  handleDeleteNode(node) {
    if (this.currentData) {
      this.undoManager.saveSnapshot(this.currentData);
    }
    const deleteSuccess = this.mindMapService.deleteNode(node.data);
    if (deleteSuccess) {
      this.clearSelection();
      this.triggerDataUpdate();
    }
  }
  async handleCopyNode(node) {
    await this.clipboardManager.copyNode(node);
  }
  async handleCutNode(node) {
    if (this.currentData) {
      this.undoManager.saveSnapshot(this.currentData);
    }
    await this.clipboardManager.cutNode(node);
  }
  async handlePasteToNode(node) {
    if (this.currentData) {
      this.undoManager.saveSnapshot(this.currentData);
    }
    await this.clipboardManager.pasteToNode(node);
  }
  /**
   * 
   *  InteractionManager 
   */
  handleExitEditMode() {
    if (this.nodeEditor.isEditing()) {
      this.nodeEditor.saveText();
    }
  }
  // ==========  ==========
  enterEditModeForNode(node) {
    const targetElement = selectAll_default2(".nodes g").filter((d) => d.data === node.data).select(".node-unified-text").node();
    if (targetElement) {
      this.nodeEditor.enableEditing(node, targetElement);
    }
  }
  selectNode(node) {
    this.selectedNode = node;
    node.data.selected = true;
    selectAll_default2(".node-rect").filter((d) => d === node).classed("selected-rect", true);
  }
  clearSelection() {
    if (this.nodeEditor.isEditing()) {
      this.nodeEditor.saveText();
      return;
    }
    if (this.currentData && this.currentData.rootNode) {
      this.clearAllSelectionStates(this.currentData.rootNode);
    }
    selectAll_default2(".node-rect").classed("selected-rect", false).classed("hovered-rect", false);
    this.selectedNode = null;
    this.hoveredNode = null;
    selectAll_default2(".plus-button-group").remove();
    selectAll_default2(".ai-suggest-button-group").remove();
    if (this.config.isMobile && this.mobileToolbar) {
      this.mobileToolbar.hide();
    }
  }
  /**
   * 
   * 
   */
  clearAllSelectionStates(node) {
    node.selected = false;
    node.hovered = false;
    for (const child of node.children) {
      this.clearAllSelectionStates(child);
    }
  }
  /**
   * 
   * 
   */
  validateSelectionState() {
    if (!this.currentData || !this.currentData.rootNode) {
      return;
    }
    let selectedCount = 0;
    let firstSelected = null;
    this.currentData.allNodes.forEach((node) => {
      if (node.selected) {
        selectedCount++;
        if (!firstSelected) {
          firstSelected = node;
        }
      }
    });
    if (selectedCount > 1) {
      console.warn(`[Selection] Found ${selectedCount} selected nodes, clearing all except first`);
      this.currentData.allNodes.forEach((node) => {
        if (node !== firstSelected && node.selected) {
          node.selected = false;
        }
      });
    }
  }
  // ==========  ==========
  /**
   * 
   * 
   */
  calculateDynamicTreeHeight(root2) {
    let maxDepth = 0;
    let nodesAtDepth = {};
    root2.each((node) => {
      maxDepth = Math.max(maxDepth, node.depth);
      if (!nodesAtDepth[node.depth]) {
        nodesAtDepth[node.depth] = [];
      }
      nodesAtDepth[node.depth].push(node);
    });
    let totalHeight = 0;
    for (let depth = 0; depth <= maxDepth; depth++) {
      const nodes = nodesAtDepth[depth] || [];
      const layerHeight = this.calculateAdaptiveLayerHeight(nodes);
      let depthMultiplier = 1;
      if (depth === 0) {
        depthMultiplier = 0.8;
      } else if (depth === 1) {
        depthMultiplier = 1;
      } else if (depth === 2) {
        depthMultiplier = 1.3;
      } else if (depth === 3) {
        depthMultiplier = 1.8;
      } else {
        depthMultiplier = 2.2 + (depth - 4) * 0.3;
      }
      const verticalSpacing = this.layoutConfig.verticalSpacing * depthMultiplier;
      const nodeCount = nodes.length;
      if (nodeCount > 3) {
        const nodeCountMultiplier = 1 + (nodeCount - 3) * 0.1;
        totalHeight += layerHeight + verticalSpacing * nodeCountMultiplier;
      } else {
        totalHeight += layerHeight + verticalSpacing;
      }
    }
    const minHeight = Math.max(totalHeight, this.layoutConfig.treeHeight);
    const depthBuffer = Math.max(100, maxDepth * 25);
    return minHeight + depthBuffer;
  }
  /**
   * 
   * 
   */
  calculateAdaptiveLayerHeight(nodes) {
    if (nodes.length === 0) return 60;
    let maxHeight = 0;
    let totalTextLength = 0;
    nodes.forEach((node) => {
      const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);
      maxHeight = Math.max(maxHeight, dimensions.height);
      totalTextLength += node.data.text.length;
    });
    const textLengthBonus = Math.min(totalTextLength / nodes.length * 2, 50);
    const adaptiveHeight = maxHeight + textLengthBonus;
    const minHeight = nodes[0].depth === 0 ? 80 : nodes[0].depth === 1 ? 70 : 60;
    return Math.max(adaptiveHeight, minHeight);
  }
  // ==========  ==========
  /**
   *  SVG 
   * 
   */
  createGradientDefinitions(svg) {
    const defs = svg.append("defs");
    const linkGradient = defs.append("linearGradient").attr("id", "linkGradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
    linkGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--interactive-accent)").attr("stop-opacity", 0.8);
    linkGradient.append("stop").attr("offset", "50%").attr("stop-color", "var(--interactive-accent-hover)").attr("stop-opacity", 1);
    linkGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--text-accent)").attr("stop-opacity", 0.6);
  }
  /**
   * 
   *  selectedNode  D3 
   */
  syncSelectedNodeReference(root2) {
    if (!this.selectedNode || !this.selectedNode.data) {
      return;
    }
    const targetNode = this.selectedNode.data;
    let foundNode = null;
    root2.each((d) => {
      if (d.data === targetNode) {
        foundNode = d;
      }
    });
    if (foundNode) {
      this.selectedNode = foundNode;
    } else {
      this.selectedNode = null;
    }
  }
  /**
   *  UI
   * 
   */
  restoreSelectionUI() {
    if (!this.currentSvg) return;
    this.currentSvg.selectAll(".node").each((d, i, nodes) => {
      if (d.data.selected) {
        const nodeElement = select_default2(nodes[i]);
        const dimensions = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);
        this.buttonRenderer.renderPlusButton(nodeElement, d, dimensions);
        this.aiAssistant.renderAIButton(nodeElement, d, dimensions);
      }
    });
  }
  /**
   * 
   * 
   */
  restoreViewState() {
    if (this.currentZoomTransform && this.currentSvg && this.currentZoom) {
      const svgNode2 = this.currentSvg.node();
      if (!svgNode2) {
        return;
      }
      const currentTransform = transform(svgNode2);
      if (currentTransform.toString() !== this.currentZoomTransform.toString()) {
        this.currentSvg.call(this.currentZoom.transform, this.currentZoomTransform);
        if (this.currentContent) {
          this.currentContent.attr("transform", this.currentZoomTransform);
        }
      }
    }
  }
  /**
   * 
   * 
   */
  editNewNode() {
    if (!this.selectedNode || !this.currentSvg) {
      return;
    }
    const nodeElements = selectAll_default2(".nodes g");
    const targetElement = nodeElements.filter((d) => d === this.selectedNode).select(".node-unified-text").node();
    if (targetElement) {
      this.nodeEditor.enableEditing(this.selectedNode, targetElement);
    }
  }
  triggerDataUpdate() {
    var _a;
    (_a = this.onDataUpdated) == null ? void 0 : _a.call(this);
  }
  // ========== Undo/Redo  ==========
  /**
   * 
   * @returns  true false
   */
  undo() {
    var _a;
    if (!this.undoManager.canUndo()) {
      return false;
    }
    const previousData = this.undoManager.undo(this.currentData);
    if (previousData && this.currentData) {
      this.currentData.rootNode = previousData.rootNode;
      this.currentData.allNodes = previousData.allNodes;
      this.currentData.maxLevel = previousData.maxLevel;
      this.clearSelection();
      (_a = this.onDataRestored) == null ? void 0 : _a.call(this, previousData);
      this.triggerDataUpdate();
      return true;
    }
    return false;
  }
  /**
   * 
   * @returns  true false
   */
  redo() {
    var _a;
    if (!this.undoManager.canRedo()) {
      return false;
    }
    const nextData = this.undoManager.redo(this.currentData);
    if (nextData && this.currentData) {
      this.currentData.rootNode = nextData.rootNode;
      this.currentData.allNodes = nextData.allNodes;
      this.currentData.maxLevel = nextData.maxLevel;
      this.clearSelection();
      (_a = this.onDataRestored) == null ? void 0 : _a.call(this, nextData);
      this.triggerDataUpdate();
      return true;
    }
    return false;
  }
  /**
   * 
   */
  canUndo() {
    return this.undoManager.canUndo();
  }
  /**
   * 
   */
  canRedo() {
    return this.undoManager.canRedo();
  }
  /**
   * 
   */
  clearHistory() {
    this.undoManager.clearHistory();
  }
  /**
   *  UndoManager  KeyboardManager
   */
  getUndoManager() {
    return this.undoManager;
  }
};

// src/renderers/desktop-tree-renderer.ts
var DesktopTreeRenderer = class {
  /**
   * Constructor - creates the renderer coordinator
   *
   * @param app - Obsidian app instance (not used directly, available for future extensions)
   * @param config - Configuration object with desktop-specific settings
   * @param mindMapService - MindMap service instance
   * @param messages - i18n messages object
   */
  constructor(app, config, mindMapService, messages, isActiveView) {
    this.rendererCoordinator = new RendererCoordinator(
      mindMapService,
      config,
      messages,
      isActiveView
    );
  }
  /**
   * Render mind map data
   * Delegates to RendererCoordinator
   *
   * @param container - DOM element to render into
   * @param data - Mind map data structure
   */
  render(container, data) {
    this.rendererCoordinator.render(container, data);
  }
  /**
   * Destroy the renderer and clean up resources
   * Delegates to RendererCoordinator
   */
  destroy() {
    this.rendererCoordinator.destroy();
  }
  /**
   * Get the underlying renderer coordinator
   * Useful for accessing coordinator methods during transition period
   */
  getRendererCoordinator() {
    return this.rendererCoordinator;
  }
  /**
   * onTextChanged callback getter/setter
   * Exposes RendererCoordinator's callback property for external use
   */
  get onTextChanged() {
    return this.rendererCoordinator.onTextChanged;
  }
  set onTextChanged(callback) {
    this.rendererCoordinator.onTextChanged = callback;
  }
  /**
   * onDataUpdated callback getter/setter
   * Exposes RendererCoordinator's callback property for external use
   */
  get onDataUpdated() {
    return this.rendererCoordinator.onDataUpdated;
  }
  set onDataUpdated(callback) {
    this.rendererCoordinator.onDataUpdated = callback;
  }
};

// src/renderers/mobile-tree-renderer.ts
var MobileTreeRenderer = class extends DesktopTreeRenderer {
  /**
   * Constructor - initializes mobile renderer
   *
   * @param app - Obsidian app instance
   * @param config - Configuration object with mobile-specific settings (config.isMobile = true)
   * @param mindMapService - MindMap service instance
   * @param messages - i18n messages object
   */
  constructor(app, config, mindMapService, messages, isActiveView) {
    super(app, config, mindMapService, messages, isActiveView);
  }
  /**
   * Render mind map data with mobile optimizations
   *
   * @param container - DOM element to render into
   * @param data - Mind map data structure
   */
  render(container, data) {
    container.classList.add("is-mobile");
    super.render(container, data);
  }
  /**
   * Destroy the renderer and clean up resources
   */
  destroy() {
    const container = document.querySelector(".mind-map-container.is-mobile");
    if (container) {
      container.classList.remove("is-mobile");
    }
    super.destroy();
  }
};

// src/renderers/renderer-manager.ts
var RendererManager = class {
  /**
   * Constructor - performs device detection and creates renderer
   *
   * @param app - Obsidian app instance
   * @param config - Configuration object from ConfigManager
   * @param mindMapService - MindMap service instance
   * @param messages - Internationalization messages (optional)
   * @param isActiveView - Callback to check if mindmap view is active (optional)
   *
   * Early Branching Pattern:
   * The device detection happens here at initialization time based on config.isMobile.
   * This guarantees that:
   * - Desktop devices always use DesktopTreeRenderer
   * - Mobile devices always use MobileTreeRenderer
   * - No mixing of code paths during operation
   */
  constructor(app, config, mindMapService, messages, isActiveView) {
    if (config.isMobile) {
      this.renderer = new MobileTreeRenderer(app, config, mindMapService, messages, isActiveView);
    } else {
      this.renderer = new DesktopTreeRenderer(app, config, mindMapService, messages, isActiveView);
    }
  }
  /**
   * Render mind map data
   * Delegates to the device-specific renderer
   *
   * @param container - DOM element to render into
   * @param data - Mind map data structure
   */
  render(container, data) {
    this.renderer.render(container, data);
  }
  /**
   * Destroy the renderer and clean up resources
   * Delegates to the device-specific renderer
   */
  destroy() {
    this.renderer.destroy();
  }
  /**
   * Get the active renderer instance
   * Useful for debugging and testing
   */
  getActiveRenderer() {
    return this.renderer;
  }
  /**
   * Get device type
   * @returns true if mobile renderer is active, false if desktop
   */
  isMobile() {
    return this.renderer instanceof MobileTreeRenderer;
  }
  /**
   * onTextChanged callback getter/setter
   * Delegates to the internal renderer (DesktopTreeRenderer or MobileTreeRenderer)
   */
  get onTextChanged() {
    return this.renderer.onTextChanged;
  }
  set onTextChanged(callback) {
    this.renderer.onTextChanged = callback;
  }
  /**
   * onDataUpdated callback getter/setter
   * Delegates to the internal renderer (DesktopTreeRenderer or MobileTreeRenderer)
   */
  get onDataUpdated() {
    return this.renderer.onDataUpdated;
  }
  set onDataUpdated(callback) {
    this.renderer.onDataUpdated = callback;
  }
};

// src/services/mindmap-service.ts
var import_obsidian5 = require("obsidian");

// src/handlers/file-handler.ts
var import_obsidian4 = require("obsidian");
var D3FileHandler = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Check if a file should be displayed as a mind map
   */
  async isMindMapFile(file) {
    if (file.extension !== "md") {
      return false;
    }
    try {
      const content = await this.app.vault.read(file);
      return isMindMapFile(content, file.extension);
    } catch (error) {
      console.error("Failed to check if file is mind map:", file.path, error);
      return false;
    }
  }
  /**
   * Load file content
   */
  async loadFileContent(file) {
    try {
      return await this.app.vault.read(file);
    } catch (error) {
      throw new Error(`Failed to load file: ${file.path}`);
    }
  }
  /**
   * Parse markdown content to mind map nodes
   */
  parseMarkdownToNodes(content) {
    const { allNodes } = parseMarkdownContent(content, "unknown.md");
    return allNodes;
  }
  /**
   * Parse markdown content to complete mind map data
   */
  parseMarkdownToData(content, filePath) {
    return parseMarkdownContent(content, filePath);
  }
  /**
   * Save mind map data to markdown file
   */
  async saveToMarkdownFile(filePath, rootNode) {
    try {
      const newContent = generateMarkdownFromNodes(rootNode);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian4.TFile) {
        await this.app.vault.process(file, () => {
          return newContent;
        });
      } else {
        throw new Error(`File not found: ${filePath}`);
      }
    } catch (error) {
      throw new Error(`Failed to save file: ${filePath}`);
    }
  }
  /**
   * Create a new mind map file
   */
  async createMindMapFile(filePath, title) {
    try {
      const content = `#mindmap

* ${title}
`;
      return await this.app.vault.create(filePath, content);
    } catch (error) {
      throw new Error(`Failed to create file: ${filePath}`);
    }
  }
  /**
   * Check if file exists
   */
  fileExists(filePath) {
    return this.app.vault.getAbstractFileByPath(filePath) !== null;
  }
};

// src/i18n/en.ts
var en = {
  // ==================== Notices () ====================
  notices: {
    // File operations
    fileCreated: "\u2705 Created new mindmap file: {fileName}",
    fileCreateFailed: "\u274C Failed to create file",
    fileCreateError: "\u274C Failed to create file: {error}",
    // Node operations
    nodeDeleted: "Node deleted successfully",
    cannotDeleteRoot: "\u26A0\uFE0F Central topic (root node) cannot be deleted",
    cannotDeleteNoParent: "\u26A0\uFE0F Node has no parent, cannot delete",
    nodeCreated: "Created: {nodeText}",
    nodeCreateFailed: "Failed to create node: {error}",
    // Editing operations
    nodeTextCopied: "Node text copied to clipboard",
    copyFailed: "Copy failed, please copy manually",
    alreadyAdded: "Already added: {nodeText}",
    // AI operations
    aiAnalyzing: '\u{1F916} AI is analyzing "{nodeText}"...',
    aiNoSuggestions: "No suggestions generated. Try rephrasing your prompt.",
    aiFailed: "\u274C AI suggestions failed: {error}",
    // Settings
    apiConnectionSuccess: "\u2705 API connection successful!",
    apiConnectionFailed: "\u274C API connection failed. Check settings for details.",
    apiTestTimeout: "Request timeout after 10 seconds. The API server is not responding. Please check your network connection and API URL.",
    promptsReset: "\u2705 Prompt templates reset to default",
    deviceTypeChanged: "Device type changed. Reload Obsidian to apply changes.",
    connectionTestFailed: "\u274C Connection test failed",
    // Language
    languageChanged: "Language changed to {language}. Reload Obsidian to apply changes.",
    // Editing
    editSuccess: "Node text updated successfully"
  },
  // ==================== Errors () ====================
  errors: {
    // File errors
    fileNotFound: "Error: File not found: {filePath}",
    fileLoadError: "Error loading file: {error}",
    noMindmapFile: "No mind map file specified or found. Make sure the file starts with #mindmap",
    // API errors
    apiKeyNotConfigured: "\u274C Error: API key is not configured. Please enter your API key in settings.",
    apiBaseUrlNotConfigured: "\u274C Error: API base URL is not configured.",
    apiError: "\u274C Error: {error}",
    networkError: "\u274C Network error: {error}. Please check your internet connection and API URL.",
    // Validation errors
    nodeTextEmpty: "Node text cannot be empty",
    nodeTextInvalid: "Node text cannot be empty or contain invalid characters",
    focusSetFailed: "Failed to set focus, please try again",
    enterEditModeFailed: "Failed to enter edit mode, please try again",
    saveFailed: "Save failed, please try again",
    editElementNotFound: "Edit element not found",
    textElementNotFound: "Text element not found",
    enterEditModeError: "Error entering edit mode",
    // AI errors
    emptyNodeError: "Node text is empty. Please add text to the node first.",
    // General errors
    serviceNotAvailable: "Mind map service not available",
    error: "Error: {message}"
  },
  // ==================== Validation () ====================
  validation: {
    cannotEditRoot: "Central topic (filename) cannot be modified",
    cannotPasteRoot: "Cannot paste to root node",
    cannotCreateSiblingRoot: "Cannot create sibling for root node"
  },
  // ==================== Settings () ====================
  settings: {
    title: "Settings for openMindMap Plugin",
    // Device settings
    deviceSection: "Device settings",
    deviceType: "Device type",
    deviceTypeDesc: "Choose how mind maps should be rendered. Auto-detects based on your device.",
    deviceAuto: "Auto-detect",
    deviceDesktop: "Desktop mode",
    deviceMobile: "Mobile mode",
    // Language settings
    languageSection: "Language settings",
    language: "Language",
    languageDesc: "Choose your preferred language for the plugin interface.",
    languageEnglish: "English",
    languageChinese: "\u4E2D\u6587",
    // AI configuration
    aiSection: "AI configuration (OpenAI-compatible API)",
    aiSectionDesc: "Configure your AI API to enable intelligent features like automatic node suggestions.",
    aiSecurity: "\u{1F512} Security: Your API key is encrypted using AES-GCM (256-bit) before storage. The encrypted key is stored in data.json and can only be decrypted on this device.",
    aiBaseUrl: "OpenAI API base URL",
    aiBaseUrlDesc: "The base URL for your OpenAI-compatible API (e.g., https://api.openai.com/v1)",
    aiBaseUrlPlaceholder: "https://api.openai.com/v1",
    aiApiKey: "OpenAI API key",
    aiApiKeyDesc: "Your OpenAI API key (starts with sk-...)",
    aiApiKeyPlaceholder: "sk-...",
    aiModel: "Model name",
    aiModelDesc: "The model name to use (e.g., gpt-3.5-turbo, gpt-4, llama2, mistral, etc.)",
    aiModelPlaceholder: "gpt-3.5-turbo",
    aiTestConnection: "Test connection",
    aiTestConnectionDesc: "Test your API configuration to ensure it works correctly",
    aiTestButton: "Test connection",
    aiTesting: "Testing...",
    // AI prompt configuration
    aiPromptSection: "AI prompt configuration",
    aiPromptSectionDesc: "Customize how the AI generates suggestions by editing the system message and prompt template.",
    aiSystemMessage: "AI system message",
    aiSystemMessageDesc: "Define the AI assistant role and behavior. This sets the context for all AI interactions.",
    aiSystemMessagePlaceholder: "You are a helpful mind map assistant...",
    aiPromptTemplate: "AI prompt template",
    aiPromptTemplateDesc: "Customize the prompt template for node suggestions. Available variables: {nodeText}, {level}, {parentContext}, {siblingsContext}, {existingChildren}, {centralTopic}",
    aiPromptTemplatePlaceholder: "Please suggest 3-5 child nodes...",
    aiPromptVariables: "Available variables:",
    aiPromptVariableNodeText: "{nodeText}: The text content of the current node",
    aiPromptVariableLevel: "{level}: The hierarchy level of the current node (0=root, 1=first level, etc.)",
    aiPromptVariableParent: "{parentContext}: Context from the parent node",
    aiPromptVariableSiblings: "{siblingsContext}: Context from sibling nodes",
    aiPromptVariableChildren: "{existingChildren}: Existing child nodes of the current node",
    aiPromptVariableCentral: "{centralTopic}: The root/central topic of the mind map",
    aiResetPrompts: "Reset prompts",
    aiResetPromptsDesc: "Reset prompt templates to default values",
    aiResetButton: "Reset to defaults"
  },
  // ==================== UI Elements () ====================
  ui: {
    // Commands
    commandOpenView: "Open mind map view",
    commandOpenAsMindmap: "Open current file as mind map",
    // Loading
    loading: "Loading openMindMap...",
    initializing: "Initializing...",
    loadingFile: "Loading file...",
    // Headers
    appHeader: "\u{1F9E0} openMindMap",
    debugInfo: "Debug Info:",
    instanceFilePath: "Instance filePath:",
    stateLoaded: "State loaded:",
    activeFile: "Active file:",
    // Context menu
    createNewFile: "New openMindMap file",
    contextEdit: "Edit",
    contextCopy: "Copy",
    contextPaste: "Paste",
    contextDelete: "Delete",
    // AI panel
    aiSuggestionsTitle: "\u2728 AI Suggestions",
    aiAddAll: "Add All",
    aiAddAllTooltip: "Create all suggestions",
    aiClose: "\u2715",
    // Edit hints (device-specific)
    editHintDesktop: "Double-click to edit | Enter: Save | Alt+Enter: New line | Escape: Cancel",
    editHintMobile: "Tap to edit | Enter: New line | Tap outside to save"
  },
  // ==================== Helper Methods ====================
  format(message, params) {
    return message.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== void 0 ? String(params[key]) : match;
    });
  }
};

// src/i18n/zh.ts
var zh = {
  // ==================== Notices () ====================
  notices: {
    // File operations
    fileCreated: "\u2705 \u5DF2\u521B\u5EFA\u65B0\u7684 mindmap \u6587\u4EF6\uFF1A{fileName}",
    fileCreateFailed: "\u274C \u521B\u5EFA\u6587\u4EF6\u5931\u8D25",
    fileCreateError: "\u274C \u521B\u5EFA\u6587\u4EF6\u5931\u8D25\uFF1A{error}",
    // Node operations
    nodeDeleted: "\u8282\u70B9\u5DF2\u5220\u9664",
    cannotDeleteRoot: "\u26A0\uFE0F \u4E2D\u5FC3\u4E3B\u9898\uFF08\u6839\u8282\u70B9\uFF09\u4E0D\u80FD\u5220\u9664",
    cannotDeleteNoParent: "\u26A0\uFE0F \u8282\u70B9\u6CA1\u6709\u7236\u8282\u70B9\uFF0C\u65E0\u6CD5\u5220\u9664",
    nodeCreated: "\u5DF2\u521B\u5EFA\uFF1A{nodeText}",
    nodeCreateFailed: "\u521B\u5EFA\u8282\u70B9\u5931\u8D25\uFF1A{error}",
    // Editing operations
    nodeTextCopied: "\u8282\u70B9\u6587\u672C\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    copyFailed: "\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u590D\u5236",
    alreadyAdded: "\u5DF2\u6DFB\u52A0\uFF1A{nodeText}",
    // AI operations
    aiAnalyzing: '\u{1F916} AI \u6B63\u5728\u5206\u6790"{nodeText}"...',
    aiNoSuggestions: "\u672A\u751F\u6210\u5EFA\u8BAE\u3002\u5C1D\u8BD5\u91CD\u65B0\u8868\u8FF0\u60A8\u7684\u63D0\u793A\u8BCD\u3002",
    aiFailed: "\u274C AI \u5EFA\u8BAE\u5931\u8D25\uFF1A{error}",
    // Settings
    apiConnectionSuccess: "\u2705 API \u8FDE\u63A5\u6210\u529F\uFF01",
    apiConnectionFailed: "\u274C API \u8FDE\u63A5\u5931\u8D25\u3002\u8BF7\u68C0\u67E5\u8BBE\u7F6E\u8BE6\u60C5\u3002",
    apiTestTimeout: "\u8BF7\u6C42\u8D85\u65F6\uFF0810\u79D2\uFF09\u3002API \u670D\u52A1\u5668\u672A\u54CD\u5E94\u3002\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u548C API URL\u3002",
    promptsReset: "\u2705 \u63D0\u793A\u8BCD\u6A21\u677F\u5DF2\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C",
    deviceTypeChanged: "\u8BBE\u5907\u7C7B\u578B\u5DF2\u66F4\u6539\u3002\u8BF7\u91CD\u65B0\u52A0\u8F7D Obsidian \u4EE5\u5E94\u7528\u66F4\u6539\u3002",
    connectionTestFailed: "\u274C \u8FDE\u63A5\u6D4B\u8BD5\u5931\u8D25",
    // Language
    languageChanged: "\u8BED\u8A00\u5DF2\u66F4\u6539\u4E3A {language}\u3002\u91CD\u65B0\u52A0\u8F7D Obsidian \u4EE5\u5E94\u7528\u66F4\u6539\u3002",
    // Editing
    editSuccess: "\u8282\u70B9\u6587\u672C\u5DF2\u66F4\u65B0"
  },
  // ==================== Errors () ====================
  errors: {
    // File errors
    fileNotFound: "\u9519\u8BEF\uFF1A\u672A\u627E\u5230\u6587\u4EF6\uFF1A{filePath}",
    fileLoadError: "\u52A0\u8F7D\u6587\u4EF6\u65F6\u51FA\u9519\uFF1A{error}",
    noMindmapFile: "\u672A\u6307\u5B9A\u6216\u672A\u627E\u5230\u601D\u7EF4\u5BFC\u56FE\u6587\u4EF6\u3002\u8BF7\u786E\u4FDD\u6587\u4EF6\u4EE5 #mindmap \u5F00\u5934",
    // API errors
    apiKeyNotConfigured: "\u274C \u9519\u8BEF\uFF1A\u672A\u914D\u7F6E API \u5BC6\u94A5\u3002\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u8F93\u5165\u60A8\u7684 API \u5BC6\u94A5\u3002",
    apiBaseUrlNotConfigured: "\u274C \u9519\u8BEF\uFF1A\u672A\u914D\u7F6E API \u57FA\u7840 URL\u3002",
    apiError: "\u274C \u9519\u8BEF\uFF1A{error}",
    networkError: "\u274C \u7F51\u7EDC\u9519\u8BEF\uFF1A{error}\u3002\u8BF7\u68C0\u67E5\u60A8\u7684\u4E92\u8054\u7F51\u8FDE\u63A5\u548C API URL\u3002",
    // Validation errors
    nodeTextEmpty: "\u8282\u70B9\u6587\u672C\u4E0D\u80FD\u4E3A\u7A7A",
    nodeTextInvalid: "\u8282\u70B9\u6587\u672C\u4E0D\u80FD\u4E3A\u7A7A\u6216\u5305\u542B\u65E0\u6548\u5B57\u7B26",
    focusSetFailed: "\u7126\u70B9\u8BBE\u7F6E\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
    enterEditModeFailed: "\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
    saveFailed: "\u4FDD\u5B58\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
    editElementNotFound: "\u65E0\u6CD5\u627E\u5230\u7F16\u8F91\u5143\u7D20",
    textElementNotFound: "\u65E0\u6CD5\u627E\u5230\u6587\u672C\u5143\u7D20",
    enterEditModeError: "\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F\u65F6\u53D1\u751F\u9519\u8BEF",
    // AI errors
    emptyNodeError: "\u8282\u70B9\u6587\u672C\u4E3A\u7A7A\u3002\u8BF7\u5148\u4E3A\u8282\u70B9\u6DFB\u52A0\u6587\u672C\u3002",
    // General errors
    serviceNotAvailable: "\u601D\u7EF4\u5BFC\u56FE\u670D\u52A1\u4E0D\u53EF\u7528",
    error: "\u9519\u8BEF\uFF1A{message}"
  },
  // ==================== Validation () ====================
  validation: {
    cannotEditRoot: "\u4E2D\u5FC3\u4E3B\u9898\uFF08\u6587\u4EF6\u540D\uFF09\u4E0D\u5141\u8BB8\u4FEE\u6539",
    cannotPasteRoot: "\u65E0\u6CD5\u7C98\u8D34\u5230\u6839\u8282\u70B9",
    cannotCreateSiblingRoot: "\u65E0\u6CD5\u4E3A\u6839\u8282\u70B9\u521B\u5EFA\u5144\u5F1F\u8282\u70B9"
  },
  // ==================== Settings () ====================
  settings: {
    title: "openMindMap \u63D2\u4EF6\u8BBE\u7F6E",
    // Device settings
    deviceSection: "\u8BBE\u5907\u8BBE\u7F6E",
    deviceType: "\u8BBE\u5907\u7C7B\u578B",
    deviceTypeDesc: "\u9009\u62E9\u601D\u7EF4\u5BFC\u56FE\u7684\u6E32\u67D3\u65B9\u5F0F\u3002\u5C06\u6839\u636E\u60A8\u7684\u8BBE\u5907\u81EA\u52A8\u68C0\u6D4B\u3002",
    deviceAuto: "\u81EA\u52A8\u68C0\u6D4B",
    deviceDesktop: "\u684C\u9762\u6A21\u5F0F",
    deviceMobile: "\u79FB\u52A8\u6A21\u5F0F",
    // Language settings
    languageSection: "\u8BED\u8A00\u8BBE\u7F6E",
    language: "\u8BED\u8A00",
    languageDesc: "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u7684\u9996\u9009\u8BED\u8A00\u3002",
    languageEnglish: "English",
    languageChinese: "\u4E2D\u6587",
    // AI configuration
    aiSection: "AI \u914D\u7F6E\uFF08OpenAI \u517C\u5BB9 API\uFF09",
    aiSectionDesc: "\u914D\u7F6E\u60A8\u7684 AI API \u4EE5\u542F\u7528\u667A\u80FD\u529F\u80FD\uFF0C\u5982\u81EA\u52A8\u8282\u70B9\u5EFA\u8BAE\u3002",
    aiSecurity: "\u{1F512} \u5B89\u5168\u6027\uFF1A\u60A8\u7684 API \u5BC6\u94A5\u5728\u5B58\u50A8\u524D\u4F7F\u7528 AES-GCM\uFF08256 \u4F4D\uFF09\u52A0\u5BC6\u3002\u52A0\u5BC6\u540E\u7684\u5BC6\u94A5\u5B58\u50A8\u5728 data.json \u4E2D\uFF0C\u53EA\u80FD\u5728\u6B64\u8BBE\u5907\u4E0A\u89E3\u5BC6\u3002",
    aiBaseUrl: "OpenAI API \u57FA\u7840 URL",
    aiBaseUrlDesc: "\u60A8\u7684 OpenAI \u517C\u5BB9 API \u7684\u57FA\u7840 URL\uFF08\u4F8B\u5982\uFF1Ahttps://api.openai.com/v1\uFF09",
    aiBaseUrlPlaceholder: "https://api.openai.com/v1",
    aiApiKey: "OpenAI API \u5BC6\u94A5",
    aiApiKeyDesc: "\u60A8\u7684 OpenAI API \u5BC6\u94A5\uFF08\u4EE5 sk- \u5F00\u5934\uFF09",
    aiApiKeyPlaceholder: "sk-...",
    aiModel: "\u6A21\u578B\u540D\u79F0",
    aiModelDesc: "\u8981\u4F7F\u7528\u7684\u6A21\u578B\u540D\u79F0\uFF08\u4F8B\u5982\uFF1Agpt-3.5-turbo\u3001gpt-4\u3001llama2\u3001mistral \u7B49\uFF09",
    aiModelPlaceholder: "gpt-3.5-turbo",
    aiTestConnection: "\u6D4B\u8BD5\u8FDE\u63A5",
    aiTestConnectionDesc: "\u6D4B\u8BD5\u60A8\u7684 API \u914D\u7F6E\u4EE5\u786E\u4FDD\u5176\u6B63\u5E38\u5DE5\u4F5C",
    aiTestButton: "\u6D4B\u8BD5\u8FDE\u63A5",
    aiTesting: "\u6D4B\u8BD5\u4E2D...",
    // AI prompt configuration
    aiPromptSection: "AI \u63D0\u793A\u8BCD\u914D\u7F6E",
    aiPromptSectionDesc: "\u901A\u8FC7\u7F16\u8F91\u7CFB\u7EDF\u6D88\u606F\u548C\u63D0\u793A\u8BCD\u6A21\u677F\u6765\u81EA\u5B9A\u4E49 AI \u751F\u6210\u5EFA\u8BAE\u7684\u65B9\u5F0F\u3002",
    aiSystemMessage: "AI \u7CFB\u7EDF\u6D88\u606F",
    aiSystemMessageDesc: "\u5B9A\u4E49 AI \u52A9\u624B\u7684\u89D2\u8272\u548C\u884C\u4E3A\u3002\u8FD9\u4E3A\u6240\u6709 AI \u4EA4\u4E92\u8BBE\u7F6E\u4E0A\u4E0B\u6587\u3002",
    aiSystemMessagePlaceholder: "\u4F60\u662F\u4E00\u4E2A\u6709\u7528\u7684\u601D\u7EF4\u5BFC\u56FE\u52A9\u624B...",
    aiPromptTemplate: "AI \u63D0\u793A\u8BCD\u6A21\u677F",
    aiPromptTemplateDesc: "\u81EA\u5B9A\u4E49\u8282\u70B9\u5EFA\u8BAE\u7684\u63D0\u793A\u8BCD\u6A21\u677F\u3002\u53EF\u7528\u53D8\u91CF\uFF1A{nodeText}\u3001{level}\u3001{parentContext}\u3001{siblingsContext}\u3001{existingChildren}\u3001{centralTopic}",
    aiPromptTemplatePlaceholder: "\u8BF7\u5EFA\u8BAE 3-5 \u4E2A\u5B50\u8282\u70B9...",
    aiPromptVariables: "\u53EF\u7528\u53D8\u91CF\uFF1A",
    aiPromptVariableNodeText: "{nodeText}\uFF1A\u5F53\u524D\u8282\u70B9\u7684\u6587\u672C\u5185\u5BB9",
    aiPromptVariableLevel: "{level}\uFF1A\u5F53\u524D\u8282\u70B9\u7684\u5C42\u7EA7\uFF080=\u6839\u8282\u70B9\uFF0C1=\u7B2C\u4E00\u5C42\uFF0C\u7B49\uFF09",
    aiPromptVariableParent: "{parentContext}\uFF1A\u6765\u81EA\u7236\u8282\u70B9\u7684\u4E0A\u4E0B\u6587",
    aiPromptVariableSiblings: "{siblingsContext}\uFF1A\u6765\u81EA\u5144\u5F1F\u8282\u70B9\u7684\u4E0A\u4E0B\u6587",
    aiPromptVariableChildren: "{existingChildren}\uFF1A\u5F53\u524D\u8282\u70B9\u7684\u73B0\u6709\u5B50\u8282\u70B9",
    aiPromptVariableCentral: "{centralTopic}\uFF1A\u601D\u7EF4\u5BFC\u56FE\u7684\u6839/\u4E2D\u5FC3\u4E3B\u9898",
    aiResetPrompts: "\u91CD\u7F6E\u63D0\u793A\u8BCD",
    aiResetPromptsDesc: "\u5C06\u63D0\u793A\u8BCD\u6A21\u677F\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C",
    aiResetButton: "\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C"
  },
  // ==================== UI Elements () ====================
  ui: {
    // Commands
    commandOpenView: "\u6253\u5F00\u601D\u7EF4\u5BFC\u56FE\u89C6\u56FE",
    commandOpenAsMindmap: "\u5C06\u5F53\u524D\u6587\u4EF6\u4F5C\u4E3A\u601D\u7EF4\u5BFC\u56FE\u6253\u5F00",
    // Loading
    loading: "\u6B63\u5728\u52A0\u8F7D openMindMap...",
    initializing: "\u6B63\u5728\u521D\u59CB\u5316...",
    loadingFile: "\u6B63\u5728\u52A0\u8F7D\u6587\u4EF6...",
    // Headers
    appHeader: "\u{1F9E0} openMindMap",
    debugInfo: "\u8C03\u8BD5\u4FE1\u606F\uFF1A",
    instanceFilePath: "\u5B9E\u4F8B\u6587\u4EF6\u8DEF\u5F84\uFF1A",
    stateLoaded: "\u72B6\u6001\u5DF2\u52A0\u8F7D\uFF1A",
    activeFile: "\u5F53\u524D\u6587\u4EF6\uFF1A",
    // Context menu
    createNewFile: "\u65B0\u5EFA openMindMap \u6587\u4EF6",
    contextEdit: "\u7F16\u8F91",
    contextCopy: "\u590D\u5236",
    contextPaste: "\u7C98\u8D34",
    contextDelete: "\u5220\u9664",
    // AI panel
    aiSuggestionsTitle: "\u2728 AI \u5EFA\u8BAE",
    aiAddAll: "\u5168\u90E8\u6DFB\u52A0",
    aiAddAllTooltip: "\u521B\u5EFA\u6240\u6709\u5EFA\u8BAE",
    aiClose: "\u2715",
    // Edit hints (device-specific)
    editHintDesktop: "\u53CC\u51FB\u7F16\u8F91 | Enter\uFF1A\u4FDD\u5B58 | Alt+Enter\uFF1A\u6362\u884C | Escape\uFF1A\u53D6\u6D88",
    editHintMobile: "\u70B9\u51FB\u7F16\u8F91 | Enter\uFF1A\u6362\u884C | \u70B9\u51FB\u5916\u90E8\u4FDD\u5B58"
  },
  // ==================== Helper Methods ====================
  format(message, params) {
    return message.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== void 0 ? String(params[key]) : match;
    });
  }
};

// src/i18n/i18n-manager.ts
var I18nManager = class {
  constructor(language = "en") {
    this.currentLanguage = language;
    this.messages = this.loadMessages(language);
  }
  /**
   * Load messages for a specific language
   */
  loadMessages(language) {
    switch (language) {
      case "zh":
        return zh;
      case "en":
      default:
        return en;
    }
  }
  /**
   * Get current language
   */
  getLanguage() {
    return this.currentLanguage;
  }
  /**
   * Set current language and reload messages
   */
  setLanguage(language) {
    if (language !== this.currentLanguage) {
      this.currentLanguage = language;
      this.messages = this.loadMessages(language);
    }
  }
  /**
   * Get messages object for current language
   */
  getMessages() {
    return this.messages;
  }
  /**
   * Format a message with parameters
   * @param key Message key in dot notation (e.g., 'notices.cannotDeleteRoot')
   * @param params Optional parameters to replace in message
   * @returns Formatted message string
   */
  format(key, params) {
    const message = this.getNestedValue(this.messages, key);
    if (!message) {
      return key;
    }
    if (params) {
      return this.replaceParams(message, params);
    }
    return message;
  }
  /**
   * Get nested value from object using dot notation
   */
  getNestedValue(obj, path) {
    const result = path.split(".").reduce((current, prop) => {
      if (current && typeof current === "object" && prop in current) {
        return current[prop];
      }
      return void 0;
    }, obj);
    return result || "";
  }
  /**
   * Replace parameters in message template
   * Supports {param} syntax
   */
  replaceParams(message, params) {
    return message.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== void 0 ? String(params[key]) : match;
    });
  }
};
function createI18nManager(language = "en") {
  return new I18nManager(language);
}

// src/services/mindmap-service.ts
var MindMapService = class {
  constructor(app, config, settings, aiClient) {
    this.app = app;
    this.config = config;
    this.settings = settings;
    this.aiClient = aiClient;
    const language = config.language || (settings == null ? void 0 : settings.language) || "en";
    const i18nManager = createI18nManager(language);
    this.messages = i18nManager.getMessages();
    this.fileHandler = new D3FileHandler(app);
    this.layoutCalculator = new LayoutCalculator();
  }
  /**
   * Update settings and AI client
   */
  updateSettings(settings, aiClient) {
    this.settings = settings;
    this.aiClient = aiClient;
  }
  /**
   * Update language when user changes settings
   */
  updateLanguage(language) {
    const i18nManager = createI18nManager(language);
    this.messages = i18nManager.getMessages();
  }
  /**
   * Check if a file should be displayed as a mind map
   */
  async isMindMapFile(file) {
    return this.fileHandler.isMindMapFile(file);
  }
  /**
   * Load and parse mind map data from a file
   */
  async loadMindMapData(file) {
    const content = await this.fileHandler.loadFileContent(file);
    return this.fileHandler.parseMarkdownToData(content, file.path);
  }
  /**
   * Save mind map data to a file
   */
  async saveMindMapData(filePath, rootNode) {
    await this.fileHandler.saveToMarkdownFile(filePath, rootNode);
  }
  /**
   * Save mind map data to markdown file (alias for saveMindMapData)
   */
  async saveToMarkdownFile(filePath, rootNode) {
    await this.fileHandler.saveToMarkdownFile(filePath, rootNode);
  }
  /**
   * Parse markdown content to mind map nodes
   */
  parseMarkdownToNodes(content) {
    return this.fileHandler.parseMarkdownToNodes(content);
  }
  /**
   * Parse markdown content to complete mind map data
   */
  parseMarkdownToData(content, filePath) {
    return parseMarkdownContent(content, filePath);
  }
  /**
   * Generate markdown content from nodes
   */
  generateMarkdownFromNodes(rootNode) {
    return generateMarkdownFromNodes(rootNode);
  }
  /**
   * Get layout calculator
   */
  getLayoutCalculator() {
    return this.layoutCalculator;
  }
  /**
   * Get file handler
   */
  getFileHandler() {
    return this.fileHandler;
  }
  /**
   * Create a new mind map file
   */
  async createMindMapFile(filePath, title) {
    return this.fileHandler.createMindMapFile(filePath, title);
  }
  /**
   * Check if file exists
   */
  fileExists(filePath) {
    return this.fileHandler.fileExists(filePath);
  }
  /**
   * Create a new child node for the given parent node
   */
  createChildNode(parentNode, childText = "New Node") {
    const childNode = {
      text: childText,
      level: parentNode.level + 1,
      parent: parentNode,
      children: [],
      expanded: true,
      selected: false,
      hovered: false
    };
    parentNode.children.push(childNode);
    return childNode;
  }
  /**
   * Create a new sibling node after the given node
   * (at the same level, with the same parent)
   */
  createSiblingNode(afterNode, siblingText = "New Node") {
    if (!afterNode.parent) {
      return null;
    }
    const siblingNode = {
      text: siblingText,
      level: afterNode.level,
      // Same level as sibling
      parent: afterNode.parent,
      children: [],
      expanded: true,
      selected: false,
      hovered: false
    };
    const parent = afterNode.parent;
    const childIndex = parent.children.indexOf(afterNode);
    parent.children.splice(childIndex + 1, 0, siblingNode);
    return siblingNode;
  }
  /**
   * Delete a node and all its children recursively
   */
  deleteNode(nodeToDelete) {
    if (!nodeToDelete) {
      return false;
    }
    if (nodeToDelete.level === 0) {
      new import_obsidian5.Notice(`\u26A0\uFE0F ${this.messages.notices.cannotDeleteRoot}`, 3e3);
      return false;
    }
    const parent = nodeToDelete.parent;
    if (!parent) {
      new import_obsidian5.Notice(`\u26A0\uFE0F ${this.messages.notices.cannotDeleteNoParent}`, 3e3);
      return false;
    }
    const childIndex = parent.children.indexOf(nodeToDelete);
    if (childIndex !== -1) {
      parent.children.splice(childIndex, 1);
      return true;
    }
    return false;
  }
  /**
   * Get all descendants of a node (including the node itself)
   */
  getAllDescendants(node) {
    const descendants = [node];
    const collectDescendants = (currentNode) => {
      for (const child of currentNode.children) {
        descendants.push(child);
        collectDescendants(child);
      }
    };
    collectDescendants(node);
    return descendants;
  }
  /**
   * Update the allNodes array after deletion
   */
  updateAllNodesArray(rootNode) {
    const allNodes = [];
    const buildArray = (node) => {
      allNodes.push(node);
      node.children.forEach(buildArray);
    };
    buildArray(rootNode);
    return allNodes;
  }
  /**
   * Suggest child nodes for a given node using AI
   * @param node The parent node
   * @returns Array of suggestions
   */
  async suggestChildNodes(node) {
    var _a, _b;
    if (!this.aiClient || !this.settings) {
      throw new Error("AI client or settings not configured");
    }
    const context = {
      nodeText: node.text,
      level: node.level,
      parent: (_a = node.parent) == null ? void 0 : _a.text,
      siblings: (_b = node.parent) == null ? void 0 : _b.children.filter((c) => c !== node).map((c) => c.text),
      existingChildren: node.children.map((c) => c.text),
      centralTopic: this.getCentralTopic(node)
    };
    const promptTemplate = this.settings.aiPromptTemplate;
    const systemMessage = this.settings.aiSystemMessage;
    const suggestions = await this.aiClient.suggestChildNodes(context, promptTemplate, systemMessage);
    return suggestions;
  }
  /**
   * Get the AI client
   */
  getAIClient() {
    return this.aiClient;
  }
  /**
   * Get central topic (root node text) from any node
   * @param node Any node in the mind map
   * @returns Root node text (central topic)
   */
  getCentralTopic(node) {
    let current = node;
    while (current.parent !== null) {
      current = current.parent;
    }
    return current.text;
  }
  /**
   * markdown
   * @param rootNode 
   * @returns markdown
   */
  serializeSubtreeToMarkdown(rootNode) {
    const lines = [];
    function traverse(node, depth) {
      const indent = "    ".repeat(depth - 1);
      lines.push(`${indent}* ${node.text}`);
      node.children.forEach((child) => traverse(child, depth + 1));
    }
    traverse(rootNode, 1);
    return lines.join("\n");
  }
  /**
   * markdown
   * @param markdown markdown
   * @param parentLevel 
   * @returns ,null
   */
  createSubtreeFromMarkdown(markdown, parentLevel) {
    const lines = markdown.split("\n").filter((line) => line.trim().length > 0);
    if (lines.length === 0) return null;
    let rootNode = null;
    const stack = [];
    for (const line of lines) {
      const indent = line.search(/\S/);
      const level = Math.floor(indent / 4) + 1;
      const text = line.trim().substring(1).trim();
      const newNode = {
        text,
        level: parentLevel + level,
        parent: null,
        children: [],
        expanded: true,
        selected: false,
        hovered: false
      };
      while (stack.length > 0 && stack[stack.length - 1].level >= level) {
        stack.pop();
      }
      if (stack.length > 0) {
        const parent = stack[stack.length - 1].node;
        parent.children.push(newNode);
        newNode.parent = parent;
      } else {
        rootNode = newNode;
      }
      stack.push({ node: newNode, level });
    }
    return rootNode;
  }
};

// src/config/desktop-config.ts
var DesktopConfig = class {
  /**
   * Get the complete desktop configuration
   */
  getConfig() {
    return {
      // Device identification
      isMobile: false,
      language: "en",
      // 
      // Layout configuration
      layout: this.getLayoutConfig(),
      // Style configuration
      style: this.getStyleConfig(),
      // Color configuration
      color: this.getColorConfig(),
      // Animation configuration
      animation: this.getAnimationConfig(),
      // Performance configuration
      performance: this.getPerformanceConfig(),
      // Interaction configuration
      interaction: this.getInteractionConfig()
    };
  }
  /**
   * Get layout configuration
   * Migrated from LAYOUT_CONSTANTS
   */
  getLayoutConfig() {
    return {
      // Spacing constants
      minNodeGap: LAYOUT_CONSTANTS.MIN_NODE_GAP,
      horizontalSpacing: LAYOUT_CONSTANTS.HORIZONTAL_SPACING,
      verticalSpacing: LAYOUT_CONSTANTS.VERTICAL_SPACING,
      minVerticalGap: LAYOUT_CONSTANTS.MIN_VERTICAL_GAP,
      // Adaptive horizontal spacing configuration
      adaptiveHorizontalSpacing: {
        minSpacing: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.MIN_SPACING,
        maxSpacing: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.MAX_SPACING,
        sourceNodeRatio: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.SOURCE_NODE_RATIO,
        targetNodeRatio: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.TARGET_NODE_RATIO,
        baseSpacing: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.BASE_SPACING,
        safetyMargin: LAYOUT_CONSTANTS.ADAPTIVE_HORIZONTAL_SPACING.SAFETY_MARGIN
      },
      // Canvas dimensions
      treeHeight: LAYOUT_CONSTANTS.TREE_HEIGHT,
      treeWidth: LAYOUT_CONSTANTS.TREE_WIDTH,
      canvasWidth: LAYOUT_CONSTANTS.CANVAS_WIDTH,
      canvasHeight: LAYOUT_CONSTANTS.CANVAS_HEIGHT,
      // Node spacing
      nodeHeightBuffer: LAYOUT_CONSTANTS.NODE_HEIGHT_BUFFER,
      // Centering calculations
      centerOffsetX: LAYOUT_CONSTANTS.CENTER_OFFSET_X,
      centerOffsetY: LAYOUT_CONSTANTS.CENTER_OFFSET_Y
    };
  }
  /**
   * Get style configuration
   * Migrated from STYLE_CONSTANTS
   */
  getStyleConfig() {
    return {
      // Font sizes by node level
      rootFontSize: STYLE_CONSTANTS.ROOT_FONT_SIZE,
      level1FontSize: STYLE_CONSTANTS.LEVEL_1_FONT_SIZE,
      defaultFontSize: STYLE_CONSTANTS.DEFAULT_FONT_SIZE,
      // Additional font sizes for UI components
      textMeasurementFontSize: STYLE_CONSTANTS.TEXT_MEASUREMENT_FONT_SIZE,
      interactionUiFontSize: STYLE_CONSTANTS.INTERACTION_UI_FONT_SIZE,
      // Node dimensions
      rootNodeMinWidth: STYLE_CONSTANTS.ROOT_NODE_MIN_WIDTH,
      nodeMinWidth: STYLE_CONSTANTS.NODE_MIN_WIDTH,
      // Text calculations
      charWidthRatio: STYLE_CONSTANTS.CHAR_WIDTH_RATIO,
      // Timing constants
      renderFrameDelay: STYLE_CONSTANTS.RENDER_FRAME_DELAY
    };
  }
  /**
   * Get color configuration
   * Migrated from COLOR_CONSTANTS
   */
  getColorConfig() {
    return {
      // Default node colors by level
      root_node_color: COLOR_CONSTANTS.ROOT_NODE_COLOR,
      level_1_color: COLOR_CONSTANTS.LEVEL_1_COLOR,
      default_node_color: COLOR_CONSTANTS.DEFAULT_NODE_COLOR,
      // Selection colors
      selected_node_color: COLOR_CONSTANTS.SELECTED_NODE_COLOR,
      hover_node_color: COLOR_CONSTANTS.HOVER_NODE_COLOR,
      // Link colors
      link_color: COLOR_CONSTANTS.LINK_COLOR,
      link_width: COLOR_CONSTANTS.LINK_WIDTH
    };
  }
  /**
   * Get animation configuration
   * Migrated from ANIMATION_CONSTANTS
   */
  getAnimationConfig() {
    return {
      // Transition durations (in milliseconds)
      fastTransition: ANIMATION_CONSTANTS.FAST_TRANSITION,
      normalTransition: ANIMATION_CONSTANTS.NORMAL_TRANSITION,
      slowTransition: ANIMATION_CONSTANTS.SLOW_TRANSITION,
      // Easing functions
      easingDefault: ANIMATION_CONSTANTS.EASING_DEFAULT,
      easingElastic: ANIMATION_CONSTANTS.EASING_ELASTIC
    };
  }
  /**
   * Get performance configuration
   * Migrated from PERFORMANCE_CONSTANTS
   */
  getPerformanceConfig() {
    return {
      // Rendering thresholds
      maxNodesBeforeVirtualization: PERFORMANCE_CONSTANTS.MAX_NODES_BEFORE_VIRTUALIZATION,
      // Debounce delays (in milliseconds)
      renderDebounceDelay: PERFORMANCE_CONSTANTS.RENDER_DEBOUNCE_DELAY,
      inputDebounceDelay: PERFORMANCE_CONSTANTS.INPUT_DEBOUNCE_DELAY,
      // Cache settings
      maxCacheSize: PERFORMANCE_CONSTANTS.MAX_CACHE_SIZE,
      cacheExpiryTime: PERFORMANCE_CONSTANTS.CACHE_EXPIRY_TIME
    };
  }
  /**
   * Get interaction configuration
   * Desktop-specific interaction settings
   */
  getInteractionConfig() {
    return {
      // Enable/disable features
      enableDrag: true,
      enableZoom: true,
      // Zoom configuration (desktop mouse wheel zoom)
      zoomScaleExtent: [0.5, 3],
      // Touch configuration (not applicable for desktop)
      touchTargetSize: void 0,
      enableTouchGestures: void 0
    };
  }
  /**
   * Get font size by node depth
   * Delegates to the existing utility function
   */
  getFontSizeByDepth() {
    return getFontSizeByDepth;
  }
  /**
   * Get numeric font size by node depth
   * Delegates to the existing utility function
   */
  getNumericFontSizeByDepth() {
    return getNumericFontSizeByDepth;
  }
};

// src/config/mobile-config.ts
var MobileConfig = class {
  /**
   * Get the complete mobile configuration
   * Phase 2: Returns fully optimized mobile configuration
   */
  getConfig() {
    const desktopConfig = new DesktopConfig();
    const desktopValues = desktopConfig.getConfig();
    return {
      // Device identification
      isMobile: true,
      language: "en",
      // 
      // Layout configuration - Mobile optimized
      layout: {
        // Spacing constants - Reduced by 20-30% for compact mobile screens
        minNodeGap: 20,
        // Reduced from 25 (20% reduction)
        horizontalSpacing: 154,
        // Reduced from 220 (30% reduction)
        verticalSpacing: 88,
        // Reduced from 110 (20% reduction)
        minVerticalGap: 20,
        // Reduced from 25 (20% reduction)
        // Adaptive horizontal spacing - Mobile optimized
        adaptiveHorizontalSpacing: {
          minSpacing: 56,
          // Reduced from 80 (30% reduction)
          maxSpacing: 210,
          // Reduced from 300 (30% reduction)
          sourceNodeRatio: 0.15,
          // Same as desktop
          targetNodeRatio: 0.1,
          // Same as desktop
          baseSpacing: 42,
          // Reduced from 60 (30% reduction)
          safetyMargin: 7
          // Reduced from 10 (30% reduction)
        },
        // Canvas dimensions - Same as desktop (canvas size independent of device)
        treeHeight: desktopValues.layout.treeHeight,
        treeWidth: desktopValues.layout.treeWidth,
        canvasWidth: desktopValues.layout.canvasWidth,
        canvasHeight: desktopValues.layout.canvasHeight,
        // Node spacing
        nodeHeightBuffer: 12,
        // Reduced from 15 (20% reduction)
        // Centering calculations
        centerOffsetX: desktopValues.layout.centerOffsetX,
        centerOffsetY: desktopValues.layout.centerOffsetY
      },
      // Style configuration - Mobile optimized for readability
      style: {
        // Font sizes - Slightly larger for mobile readability
        rootFontSize: desktopValues.style.rootFontSize,
        level1FontSize: "19px",
        // Increased from 18px for better readability
        defaultFontSize: "16px",
        // Increased from 15px for mobile
        // Additional font sizes
        textMeasurementFontSize: desktopValues.style.textMeasurementFontSize,
        interactionUiFontSize: desktopValues.style.interactionUiFontSize,
        // Node dimensions
        rootNodeMinWidth: desktopValues.style.rootNodeMinWidth,
        nodeMinWidth: desktopValues.style.nodeMinWidth,
        // Text calculations
        charWidthRatio: desktopValues.style.charWidthRatio,
        // Timing constants
        renderFrameDelay: desktopValues.style.renderFrameDelay
      },
      // Color configuration - Same as desktop
      color: desktopValues.color,
      // Animation configuration - Optimized for mobile performance
      animation: {
        // Transition durations - Shorter for better mobile performance
        fastTransition: 100,
        // Reduced from 150ms
        normalTransition: 200,
        // Reduced from 300ms
        slowTransition: 300,
        // Reduced from 500ms
        // Easing functions
        easingDefault: desktopValues.animation.easingDefault,
        easingElastic: desktopValues.animation.easingElastic
      },
      // Performance configuration - Mobile optimized
      performance: {
        // Rendering thresholds
        maxNodesBeforeVirtualization: desktopValues.performance.maxNodesBeforeVirtualization,
        // Debounce delays - More aggressive for mobile touch interactions
        renderDebounceDelay: 150,
        // Increased from 100ms (reduce re-renders)
        inputDebounceDelay: 400,
        // Increased from 300ms (better for touch)
        // Cache settings
        maxCacheSize: desktopValues.performance.maxCacheSize,
        cacheExpiryTime: desktopValues.performance.cacheExpiryTime
      },
      // Interaction configuration - Mobile specific
      interaction: {
        // Enable/disable features
        enableDrag: true,
        enableZoom: true,
        // Zoom configuration
        zoomScaleExtent: [0.5, 3],
        // Same as desktop
        // Mobile-specific: Touch interaction settings
        touchTargetSize: 44,
        // iOS HIG standard (44pt minimum)
        enableTouchGestures: true
        // Enable pinch zoom, touch drag
      }
    };
  }
};

// src/config/config-manager.ts
var ConfigManager = class {
  /**
   * Constructor - performs device detection and selects configuration
   *
   * @param isMobile - Device type flag from Obsidian API (app.isMobile)
   * @param language - Language setting from user preferences (default: 'en')
   *
   * Early Branching Pattern:
   * The device detection happens here at initialization time, not during
   * runtime usage. This guarantees that:
   * - Desktop devices always use DesktopConfig
   * - Mobile devices always use MobileConfig
   * - No mixing of code paths during operation
   */
  constructor(isMobile, language = "en") {
    this.language = language;
    if (isMobile) {
      this.config = new MobileConfig().getConfig();
    } else {
      this.config = new DesktopConfig().getConfig();
    }
    this.config.language = language;
  }
  /**
   * Get the complete configuration object
   *
   * @returns Complete configuration for the detected device type
   *
   * Note: This returns a frozen configuration object. The configuration
   * is determined at construction time and never changes during runtime.
   */
  getConfig() {
    return this.config;
  }
  /**
   * Update language setting
   *
   * @param language - New language setting
   */
  updateLanguage(language) {
    this.language = language;
    this.config.language = language;
  }
  /**
   * Get device type
   *
   * @returns true if mobile device, false if desktop
   */
  isMobile() {
    return this.config.isMobile;
  }
  /**
   * Get layout configuration section
   */
  getLayoutConfig() {
    return this.config.layout;
  }
  /**
   * Get style configuration section
   */
  getStyleConfig() {
    return this.config.style;
  }
  /**
   * Get color configuration section
   */
  getColorConfig() {
    return this.config.color;
  }
  /**
   * Get animation configuration section
   */
  getAnimationConfig() {
    return this.config.animation;
  }
  /**
   * Get performance configuration section
   */
  getPerformanceConfig() {
    return this.config.performance;
  }
  /**
   * Get interaction configuration section
   */
  getInteractionConfig() {
    return this.config.interaction;
  }
};

// src/utils/ai-client.ts
var import_obsidian6 = require("obsidian");

// src/utils/ai-prompts.ts
var AIPrompts = class {
  /**
   * Build user prompt by replacing variables in template
   * @param template Prompt template with variables
   * @param context Node context information
   * @returns Formatted prompt with variables replaced
   */
  static buildUserPrompt(template, context) {
    const result = template.replace("{nodeText}", context.nodeText).replace("{level}", String(context.level)).replace("{parentContext}", this.formatParentContext(context.parent)).replace("{siblingsContext}", this.formatSiblingsContext(context.siblings)).replace("{existingChildren}", this.formatExistingChildren(context.existingChildren)).replace("{centralTopic}", this.formatCentralTopic(context.centralTopic));
    return result;
  }
  /**
   * Format central topic (root node)
   * @param centralTopic Root node text
   * @returns Formatted central topic string
   */
  static formatCentralTopic(centralTopic) {
    if (!centralTopic) return "";
    return `Central topic: ${centralTopic}
`;
  }
  /**
   * Format parent node context
   * @param parent Parent node text
   * @returns Formatted parent context string
   */
  static formatParentContext(parent) {
    if (!parent) return "";
    return `Parent node: ${parent}
`;
  }
  /**
   * Format siblings context
   * @param siblings Array of sibling node texts
   * @returns Formatted siblings context string
   */
  static formatSiblingsContext(siblings) {
    if (!siblings || siblings.length === 0) return "";
    return `Sibling nodes: ${siblings.join(", ")}
`;
  }
  /**
   * Format existing children
   * @param children Array of existing child node texts
   * @returns Formatted children string
   */
  static formatExistingChildren(children2) {
    if (!children2 || children2.length === 0) {
      return "Current children: (none)";
    }
    return `Current children: ${children2.join(", ")}`;
  }
};

// src/utils/ai-client.ts
var AIClient = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = config;
  }
  /**
   * Test API connection by sending a simple request
   */
  async testConnection() {
    var _a;
    if (!this.config.apiKey || this.config.apiKey.trim() === "") {
      return {
        success: false,
        message: "\u274C Error: API key is not configured. Please enter your API key in settings."
      };
    }
    if (!this.config.apiBaseUrl || this.config.apiBaseUrl.trim() === "") {
      return {
        success: false,
        message: "\u274C Error: API base URL is not configured."
      };
    }
    try {
      const apiUrl = `${this.config.apiBaseUrl}/chat/completions`;
      const response = await (0, import_obsidian6.requestUrl)({
        url: apiUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: this.config.model,
          messages: [
            { role: "user", content: "Hi" }
          ],
          max_tokens: 10,
          temperature: 0.7
        })
      });
      if (response.status >= 200 && response.status < 300) {
        const data = response.json;
        try {
          this.validateAPIResponseStructure(data, "testConnection");
          return {
            success: true,
            message: "\u2705 Connection successful! API is working correctly."
          };
        } catch (validationError) {
          const errorMessage = validationError instanceof Error ? validationError.message : String(validationError);
          return {
            success: false,
            message: `\u274C API returned invalid response: ${errorMessage}`
          };
        }
      } else {
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorData = response.json;
          if ((_a = errorData.error) == null ? void 0 : _a.message) {
            errorMessage = errorData.error.message;
          }
        } catch (e) {
        }
        return {
          success: false,
          message: `\u274C Error: ${errorMessage}`
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        message: `\u274C Network error: ${errorMessage}. Please check your internet connection and API URL.`
      };
    }
  }
  /**
   * Send a chat completion request
   * This will be used in future features for node suggestions
   */
  async chat(userMessage, systemMessage) {
    var _a;
    if (!this.config.apiKey || this.config.apiKey.trim() === "") {
      throw new Error("API key is not configured");
    }
    const apiUrl = `${this.config.apiBaseUrl}/chat/completions`;
    const messages = [];
    if (systemMessage) {
      messages.push({ role: "system", content: systemMessage });
    }
    messages.push({ role: "user", content: userMessage });
    const response = await (0, import_obsidian6.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.config.apiKey}`
      },
      body: JSON.stringify({
        model: this.config.model,
        messages,
        max_tokens: 3e3,
        temperature: 0.7
      })
    });
    if (response.status < 200 || response.status >= 300) {
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorData = response.json;
        if ((_a = errorData.error) == null ? void 0 : _a.message) {
          errorMessage = errorData.error.message;
        }
      } catch (e) {
      }
      throw new Error(errorMessage);
    }
    const data = response.json;
    const content = this.validateAPIResponseStructure(data, "chat");
    return content;
  }
  /**
   * Suggest child nodes for a given node
   * @param context Node context information
   * @param promptTemplate User-configured prompt template
   * @param systemMessage System message for AI
   * @returns Array of node suggestions
   */
  async suggestChildNodes(context, promptTemplate, systemMessage) {
    try {
      if (!context.nodeText || context.nodeText.trim() === "") {
        throw new Error("Node text is empty. Please add text to the node first.");
      }
      this.validateConfiguration();
      if (promptTemplate && promptTemplate.length > 1e4) {
        throw new Error("Prompt template is too long (max 10000 characters).");
      }
      if (systemMessage && systemMessage.length > 5e3) {
        throw new Error("System message is too long (max 5000 characters).");
      }
      const userPrompt = AIPrompts.buildUserPrompt(promptTemplate, context);
      const response = await this.chat(userPrompt, systemMessage);
      const suggestions = this.parseJSONResponse(response);
      const filtered = this.deduplicateSuggestions(suggestions, context.existingChildren);
      return filtered;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (error instanceof Error) {
        throw new Error(`AI suggestion failed for node "${context.nodeText}": ${errorMessage}`);
      } else {
        throw error;
      }
    }
  }
  /**
   * Parse JSON response from AI
   * @param response AI response text
   * @returns Parsed array of suggestions
   */
  parseJSONResponse(response) {
    try {
      const jsonMatch = response.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        if (Array.isArray(parsed)) {
          return parsed.filter((item) => typeof item === "string" && item.trim().length > 0);
        }
      }
      return response.split("\n").map((line) => line.trim()).filter(
        (line) => line.length > 0 && !line.startsWith("```") && !line.startsWith("#") && !line.match(/^[0-9]+\./)
        // Remove numbered list items
      ).map((line) => line.replace(/^[-*]\s*/, ""));
    } catch (error) {
      return [];
    }
  }
  /**
   * Deduplicate suggestions against existing children
   * @param suggestions AI-generated suggestions
   * @param existingChildren Existing child nodes
   * @returns Filtered suggestions
   */
  deduplicateSuggestions(suggestions, existingChildren = []) {
    const existing = new Set(
      existingChildren.map((c) => c.toLowerCase().trim())
    );
    return suggestions.map((s) => s.trim()).filter((s) => !existing.has(s.toLowerCase())).slice(0, 5);
  }
  /**
   * Check if the client is properly configured
   */
  isConfigured() {
    return !!(this.config.apiBaseUrl && this.config.apiBaseUrl.trim() !== "" && this.config.apiKey && this.config.apiKey.trim() !== "");
  }
  /**
   * Validate API configuration
   * @throws Error if configuration is invalid
   */
  validateConfiguration() {
    if (!this.config.apiKey || this.config.apiKey.trim() === "") {
      throw new Error("API key is not configured. Please enter your API key in settings.");
    }
    if (!this.config.apiBaseUrl || this.config.apiBaseUrl.trim() === "") {
      throw new Error("API base URL is not configured.");
    }
    try {
      const url = new URL(this.config.apiBaseUrl);
      if (url.protocol !== "https:" && url.protocol !== "http:") {
        throw new Error("Invalid URL protocol.");
      }
      if (url.protocol === "http:" && url.hostname !== "localhost" && url.hostname !== "127.0.0.1") {
        throw new Error("HTTP is not secure. Please use HTTPS.");
      }
    } catch (urlError) {
      throw new Error(`Invalid API base URL format: ${this.config.apiBaseUrl}`);
    }
    if (!this.config.model || this.config.model.trim() === "") {
      throw new Error("Model name is not configured.");
    }
    if (this.config.model.length > 100) {
      throw new Error("Model name is too long (max 100 characters).");
    }
  }
  /**
   * Validate API response structure and extract content
   * @param data API response data
   * @param context Context for error messages (e.g., 'chat', 'suggestions')
   * @returns Validated content string
   * @throws Error if response structure is invalid or content is empty
   */
  validateAPIResponseStructure(data, context) {
    if (!data) {
      throw new Error("API returned empty response (no data)");
    }
    if (!data.choices || !Array.isArray(data.choices)) {
      throw new Error('API response missing "choices" array. Please check your API configuration.');
    }
    if (data.choices.length === 0) {
      throw new Error("API returned empty choices array. The model may not be compatible or may have been rate-limited.");
    }
    const finishReason = data.choices[0].finish_reason;
    if (finishReason) {
      if (finishReason === "length") {
      }
    }
    if (data.usage) {
    }
    if (!data.choices[0].message) {
      throw new Error('API response missing "message" object in first choice.');
    }
    const message = data.choices[0].message;
    let content = message.content;
    if (!content || content.trim() === "") {
      if (message.reasoning_content && message.reasoning_content.trim() !== "") {
        content = message.reasoning_content;
      }
    }
    if (content === null || content === void 0) {
      throw new Error("API returned null or undefined content. This may indicate content filtering or API limitations.");
    }
    if (typeof content !== "string") {
      throw new Error(`API returned content with invalid type: ${typeof content}. Expected string.`);
    }
    if (content.trim() === "") {
      throw new Error("API returned empty content. This may indicate:\n- Content was filtered by safety systems\n- The model name is incorrect\n- Token limit was reached (max_tokens too low)\n- API provider issues\n\nPlease check your API configuration and try again.");
    }
    return content;
  }
};

// src/utils/encryption.ts
var EncryptionUtil = class {
  /**
   * Initialize the encryption utility with device information
   * This should be called once during plugin initialization
   */
  static initialize(deviceInfo) {
    this.deviceInfo = deviceInfo;
  }
  /**
   * Generate a consistent encryption key based on device info
   * This ensures the same key is generated on the same device
   */
  static async generateKey() {
    if (this.keyPromise !== null) {
      return this.keyPromise;
    }
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      this.getKeyMaterial(),
      { name: "PBKDF2" },
      false,
      ["deriveKey"]
    );
    this.keyPromise = crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt: this.getSalt(),
        iterations: 1e5,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    return this.keyPromise;
  }
  /**
   * Get key material from device/plugin identifier
   */
  static getKeyMaterial() {
    const fallbackInfo = `obsidian-mindmap-plugin-${navigator.userAgent}-${navigator.language}`;
    const identifier = this.deviceInfo || fallbackInfo;
    return new TextEncoder().encode(identifier);
  }
  /**
   * Get salt for key derivation
   * Fixed salt ensures consistent key generation on same device
   */
  static getSalt() {
    const saltString = "mindmap-plugin-salt-2024";
    return new TextEncoder().encode(saltString);
  }
  /**
   * Encrypt text using AES-GCM
   * @param text Plain text to encrypt
   * @returns Base64 encoded encrypted data (IV + ciphertext)
   */
  static async encrypt(text) {
    if (!text) return "";
    try {
      const key = await this.generateKey();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encodedText = new TextEncoder().encode(text);
      const encryptedData = await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv
        },
        key,
        encodedText
      );
      const combined = new Uint8Array(iv.length + encryptedData.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(encryptedData), iv.length);
      return this.arrayBufferToBase64(combined);
    } catch (error) {
      throw new Error("Failed to encrypt data");
    }
  }
  /**
   * Decrypt encrypted text
   * @param encryptedData Base64 encoded encrypted data (IV + ciphertext)
   * @returns Decrypted plain text
   */
  static async decrypt(encryptedData) {
    if (!encryptedData) return "";
    try {
      const key = await this.generateKey();
      const combined = this.base64ToArrayBuffer(encryptedData);
      const iv = combined.slice(0, 12);
      const data = combined.slice(12);
      const decryptedData = await crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv
        },
        key,
        data
      );
      return new TextDecoder().decode(decryptedData);
    } catch (error) {
      console.error("Failed to decrypt API key:", error);
      throw new Error("Failed to decrypt API key. Please re-enter your API key in settings.");
    }
  }
  /**
   * Convert ArrayBuffer to Base64
   */
  static arrayBufferToBase64(buffer) {
    const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  /**
   * Convert Base64 to ArrayBuffer
   */
  static base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  /**
   * Check if a string is encrypted (heuristic check)
   * Encrypted data will be longer and contain base64 characters
   */
  static isEncrypted(text) {
    if (!text) return false;
    const base64Pattern = /^[A-Za-z0-9+/]+=*$/;
    return text.length > 50 && base64Pattern.test(text);
  }
};
EncryptionUtil.keyPromise = null;
EncryptionUtil.deviceInfo = "";

// src/main.ts
var DEFAULT_SETTINGS = {
  deviceType: "auto",
  language: "en",
  openaiApiBaseUrl: "https://api.openai.com/v1",
  openaiApiKey: "",
  openaiModel: "gpt-3.5-turbo",
  openaiApiKeyEncrypted: false,
  aiSystemMessage: "You are a professional mind map assistant, skilled at helping users expand and organize knowledge points. Please provide relevant child node suggestions based on the given node content.",
  aiPromptTemplate: `Please suggest 3-5 child nodes for the following mind map node:

Central topic: {centralTopic}
Node content: {nodeText}
Node level: {level}
{parentContext}{siblingsContext}Current children: {existingChildren}

Requirements:
1. Concise and clear (2-8 words)
2. Highly relevant to the central topic
3. Logically connected to the current node
4. Do not duplicate existing content

Please return directly in JSON array format, for example: ["suggestion1", "suggestion2", "suggestion3"]`
};
var MIND_MAP_VIEW_TYPE = "mind-map-view";
var MindMapPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    const deviceInfo = `obsidian-mindmap-plugin-${navigator.userAgent}-${navigator.language}`;
    EncryptionUtil.initialize(deviceInfo);
    let isMobileDevice;
    if (this.settings.deviceType === "auto") {
      isMobileDevice = import_obsidian7.Platform.isMobile;
    } else {
      isMobileDevice = this.settings.deviceType === "mobile";
    }
    this.configManager = new ConfigManager(isMobileDevice, this.settings.language);
    this.config = this.configManager.getConfig();
    this.mindMapService = new MindMapService(this.app, this.config, this.settings, this.aiClient);
    const i18nManager = createI18nManager(this.settings.language);
    this.messages = i18nManager.getMessages();
    await this.loadStyles();
    const ribbonIconEl = this.addRibbonIcon("brain", "openMindMap", (evt) => {
      void this.activateView();
    });
    ribbonIconEl.addClass("mind-map-ribbon-class");
    this.addCommand({
      id: "open-view",
      name: "Open Mindmap view",
      callback: () => {
        void this.activateView();
      }
    });
    this.addCommand({
      id: "open-current",
      name: "Open current file as mind map",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
        if (markdownView) {
          if (!checking) {
            void this.activateView();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "undo",
      name: "Undo",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(MindMapView);
        if (activeView) {
          if (!checking) {
            activeView.undo();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "redo",
      name: "Redo",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(MindMapView);
        if (activeView) {
          if (!checking) {
            activeView.redo();
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new MindMapSettingTab(this.app, this));
    this.registerView(
      MIND_MAP_VIEW_TYPE,
      (leaf) => new MindMapView(leaf, this.mindMapService, this.config)
    );
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (file && await this.mindMapService.isMindMapFile(file)) {
          await this.replaceWithMindMapView(file);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle(this.messages.ui.createNewFile).setIcon("brain").onClick(async () => {
            await this.createNewMindMapFile(file);
          });
        });
      })
    );
    this.app.workspace.onLayoutReady(async () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && await this.mindMapService.isMindMapFile(activeFile)) {
        void this.replaceWithMindMapView(activeFile);
      }
    });
  }
  onunload() {
    this.mindMapService = null;
    this.aiClient = null;
    this.configManager = null;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.openaiApiKey) {
      if (this.settings.openaiApiKeyEncrypted) {
        try {
          this.settings.openaiApiKey = await EncryptionUtil.decrypt(this.settings.openaiApiKey);
        } catch (error) {
          this.settings.openaiApiKeyEncrypted = false;
        }
      } else if (EncryptionUtil.isEncrypted(this.settings.openaiApiKey)) {
        try {
          this.settings.openaiApiKey = await EncryptionUtil.decrypt(this.settings.openaiApiKey);
          this.settings.openaiApiKeyEncrypted = true;
        } catch (error) {
        }
      }
    }
    const aiConfig = {
      apiBaseUrl: this.settings.openaiApiBaseUrl,
      apiKey: this.settings.openaiApiKey,
      model: this.settings.openaiModel
    };
    this.aiClient = new AIClient(aiConfig);
  }
  async saveSettings() {
    const settingsToSave = { ...this.settings };
    if (settingsToSave.openaiApiKey && !settingsToSave.openaiApiKeyEncrypted) {
      try {
        settingsToSave.openaiApiKey = await EncryptionUtil.encrypt(settingsToSave.openaiApiKey);
        settingsToSave.openaiApiKeyEncrypted = true;
      } catch (error) {
        settingsToSave.openaiApiKeyEncrypted = false;
      }
    } else if (settingsToSave.openaiApiKey && settingsToSave.openaiApiKeyEncrypted) {
      try {
        settingsToSave.openaiApiKey = await EncryptionUtil.encrypt(this.settings.openaiApiKey);
      } catch (error) {
      }
    }
    await this.saveData(settingsToSave);
    this.mindMapService.updateSettings(this.settings, this.aiClient);
  }
  async loadStyles() {
  }
  // Replace current view with mind map view
  async replaceWithMindMapView(file) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.FileView);
    if (activeView && activeView.leaf) {
      await activeView.leaf.setViewState({
        type: MIND_MAP_VIEW_TYPE,
        active: true,
        state: { file: file.path }
      });
    } else {
      const activeEditor = this.app.workspace.activeEditor;
      const editorView = activeEditor;
      const leaf = (editorView == null ? void 0 : editorView.leaf) || this.app.workspace.getMostRecentLeaf();
      if (leaf) {
        await leaf.setViewState({
          type: MIND_MAP_VIEW_TYPE,
          active: true,
          state: { file: file.path }
        });
      }
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(MIND_MAP_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: MIND_MAP_VIEW_TYPE, active: true }));
    }
    if (leaf) {
      void workspace.revealLeaf(leaf);
    }
  }
  // Create a new mindmap file with default name
  async createNewMindMapFile(contextFile) {
    var _a;
    try {
      let targetFolderPath = "";
      if (contextFile) {
        if (contextFile instanceof import_obsidian7.TFile) {
          targetFolderPath = ((_a = contextFile.parent) == null ? void 0 : _a.path) || "";
        } else if (contextFile instanceof import_obsidian7.TFolder) {
          targetFolderPath = contextFile.path;
        }
      }
      let fileName = "Untitled mindmap.md";
      let counter = 1;
      let fullPath = (0, import_obsidian7.normalizePath)(
        targetFolderPath ? `${targetFolderPath}/${fileName}` : fileName
      );
      while (this.app.vault.getAbstractFileByPath(fullPath)) {
        fileName = `Untitled mindmap ${counter}.md`;
        fullPath = (0, import_obsidian7.normalizePath)(
          targetFolderPath ? `${targetFolderPath}/${fileName}` : fileName
        );
        counter++;
      }
      const content = "#mindmap\n";
      await this.app.vault.create(fullPath, content);
      const newFile = this.app.vault.getAbstractFileByPath(fullPath);
      if (newFile instanceof import_obsidian7.TFile) {
        await this.app.workspace.getLeaf("tab").openFile(newFile);
        const message = this.messages.format(
          this.messages.notices.fileCreated,
          { fileName: fullPath }
        );
        new import_obsidian7.Notice(message);
      } else {
        new import_obsidian7.Notice(this.messages.notices.fileCreateFailed);
      }
    } catch (error) {
      const message = this.messages.format(
        this.messages.notices.fileCreateError,
        { error: error.message }
      );
      new import_obsidian7.Notice(message);
    }
  }
};
var MindMapView = class _MindMapView extends import_obsidian7.ItemView {
  constructor(leaf, mindMapService, config) {
    super(leaf);
    this.filePath = null;
    this.needsContentLoading = false;
    this.isStateLoaded = false;
    this.mindMapData = null;
    this.updateTimer = null;
    this.mindMapService = mindMapService;
    this.config = config;
    const i18nManager = createI18nManager(config.language);
    const messages = i18nManager.getMessages();
    this.renderer = new RendererManager(this.app, config, mindMapService, messages, () => this.isActiveView());
  }
  getViewType() {
    return MIND_MAP_VIEW_TYPE;
  }
  getDisplayText() {
    var _a;
    let filePath = this.filePath;
    if (!filePath) {
      try {
        const leafState = this.leaf.getViewState();
        if ((_a = leafState.state) == null ? void 0 : _a.file) {
          filePath = leafState.state.file;
          this.filePath = filePath;
        }
      } catch (error) {
      }
      if (!filePath) {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          filePath = activeFile.path;
          this.filePath = filePath;
        }
      }
    }
    if (filePath) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian7.TFile) {
        return file.basename;
      }
      const fileName = filePath.split("/").pop();
      if (fileName) {
        return fileName.replace(".md", "");
      }
    }
    return "openMindMap";
  }
  getIcon() {
    return "brain";
  }
  /**
   * 
   * 
   */
  isActiveView() {
    const activeView = this.app.workspace.getActiveViewOfType(_MindMapView);
    return activeView === this;
  }
  // Override these methods to properly handle view state
  getState() {
    return {
      file: this.filePath
    };
  }
  setState(state, result) {
    var _a;
    this.filePath = state.file || null;
    this.isStateLoaded = true;
    if (!this.filePath) {
      try {
        const leafState = this.leaf.getViewState();
        if ((_a = leafState.state) == null ? void 0 : _a.file) {
          this.filePath = leafState.state.file;
        }
      } catch (error) {
      }
    }
    if (this.needsContentLoading && this.filePath) {
      setTimeout(() => {
        void this.loadFileContent();
      }, 10);
    }
    return Promise.resolve();
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("mind-map-container");
    container.createEl("h4", { text: "Loading openMindMap..." });
    container.createEl("p", { text: "Initializing..." });
    this.renderer.onTextChanged = this.handleNodeTextChanged.bind(this);
    this.renderer.onDataUpdated = this.handleDataUpdated.bind(this);
    this.renderer.onDataRestored = this.handleDataRestored.bind(this);
    this.clearHistory();
    this.needsContentLoading = true;
    if (this.filePath) {
      await this.loadFileContent();
    }
  }
  async loadFileContent() {
    var _a, _b;
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "\u{1F9E0} openMindMap" });
    const statusEl = container.createEl("p", { text: "Loading file..." });
    let filePath = this.filePath;
    if (!filePath) {
      const state = this.leaf.getViewState();
      filePath = ((_a = state.state) == null ? void 0 : _a.file) || null;
    }
    if (!filePath) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.extension === "md") {
        try {
          const content = await this.app.vault.read(activeFile);
          if (content.trim().startsWith("#mindmap")) {
            filePath = activeFile.path;
          }
        } catch (error) {
        }
      }
    }
    this.filePath = filePath;
    if (!this.filePath) {
      statusEl.textContent = "No mind map file found";
      const errorDiv = container.createDiv("mind-map-error");
      errorDiv.createEl("strong", { text: "Error:" });
      errorDiv.createEl("br");
      errorDiv.createSpan({ text: "No mind map file specified or found." });
      errorDiv.createEl("br");
      errorDiv.createEl("br");
      errorDiv.createEl("small", { text: "Make sure the file starts with #mindmap" });
      const debugInfo = container.createEl("div", { cls: "mind-map-debug" });
      debugInfo.createEl("strong", { text: "Debug Info:" });
      debugInfo.createEl("br");
      debugInfo.createSpan({ text: `Instance filePath: ${this.filePath}` });
      debugInfo.createEl("br");
      debugInfo.createSpan({ text: `State loaded: ${this.isStateLoaded}` });
      debugInfo.createEl("br");
      debugInfo.createSpan({ text: `Active file: ${((_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.path) || "none"}` });
      return;
    }
    this.needsContentLoading = false;
    try {
      statusEl.textContent = `Loading: ${this.filePath}`;
      const file = this.app.vault.getAbstractFileByPath(this.filePath);
      if (file instanceof import_obsidian7.TFile) {
        statusEl.textContent = "Parsing content...";
        const content = await this.mindMapService.getFileHandler().loadFileContent(file);
        container.empty();
        await this.renderMindMap(content);
      } else {
        statusEl.textContent = `Error: File not found: ${this.filePath}`;
      }
    } catch (error) {
      statusEl.textContent = `Error loading file: ${error.message}`;
      const errorDiv = container.createDiv("mind-map-error");
      errorDiv.createEl("strong", { text: "Error:" });
      errorDiv.createEl("br");
      errorDiv.createSpan({ text: error.message });
    }
  }
  async renderMindMap(content) {
    const container = this.containerEl.children[1];
    container.empty();
    const mindMapData = this.mindMapService.parseMarkdownToData(content, this.filePath || "");
    this.mindMapData = mindMapData;
    this.renderer.render(container, mindMapData);
  }
  // 
  handleNodeTextChanged(node, newText) {
    if (!this.mindMapData || !this.filePath) {
      return;
    }
    node.data.text = newText;
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => {
      var _a;
      this.refreshMindMapLayout();
      if (this.filePath && ((_a = this.mindMapData) == null ? void 0 : _a.rootNode)) {
        void this.mindMapService.saveToMarkdownFile(this.filePath, this.mindMapData.rootNode);
      }
      this.updateTimer = null;
    }, 300);
  }
  // 
  handleDataUpdated() {
    if (!this.mindMapData || !this.filePath) return;
    const rootNode = this.mindMapData.rootNode;
    if (rootNode) {
      this.refreshMindMapLayout();
      void this.mindMapService.saveToMarkdownFile(this.filePath, rootNode);
    }
  }
  // undo/redo 
  handleDataRestored(data) {
    this.mindMapData = data;
    this.refreshMindMapLayout();
    if (this.filePath && data.rootNode) {
      void this.mindMapService.saveToMarkdownFile(this.filePath, data.rootNode);
    }
  }
  // 
  refreshMindMapLayout() {
    if (!this.mindMapData || !this.renderer) return;
    try {
      const container = this.containerEl.children[1];
      if (!container) return;
      requestAnimationFrame(() => {
        container.empty();
        this.renderer.render(container, this.mindMapData);
      });
    } catch (error) {
    }
  }
  // ========== Undo/Redo  ==========
  /**
   * 
   */
  undo() {
    if (this.renderer instanceof RendererCoordinator) {
      const success = this.renderer.undo();
      if (success) {
        new import_obsidian7.Notice("\u5DF2\u64A4\u9500");
      }
    }
  }
  /**
   * 
   */
  redo() {
    if (this.renderer instanceof RendererCoordinator) {
      const success = this.renderer.redo();
      if (success) {
        new import_obsidian7.Notice("\u5DF2\u91CD\u505A");
      }
    }
  }
  /**
   * 
   */
  clearHistory() {
    if (this.renderer instanceof RendererCoordinator) {
      this.renderer.clearHistory();
    }
  }
  async onClose() {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    if (this.renderer) {
      this.renderer.destroy();
    }
  }
};
var MindMapSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.testButtonHandler = null;
    this.testButton = null;
    this.plugin = plugin;
  }
  hide() {
    if (this.testButton && this.testButtonHandler) {
      this.testButton.removeEventListener("click", this.testButtonHandler);
      this.testButton = null;
      this.testButtonHandler = null;
    }
  }
  display() {
    const { containerEl } = this;
    if (this.testButton && this.testButtonHandler) {
      this.testButton.removeEventListener("click", this.testButtonHandler);
      this.testButton = null;
      this.testButtonHandler = null;
    }
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("Settings for openMindMap Plugin").setHeading();
    new import_obsidian7.Setting(containerEl).setName("Device settings").setHeading();
    new import_obsidian7.Setting(containerEl).setName("Device type").setDesc("Choose how mind maps should be rendered. Auto-detects based on your device.").addDropdown((dropdown) => dropdown.addOption("auto", "Auto-detect").addOption("desktop", "Desktop mode").addOption("mobile", "Mobile mode").setValue(this.plugin.settings.deviceType).onChange(async (value) => {
      this.plugin.settings.deviceType = value;
      await this.plugin.saveSettings();
      new import_obsidian7.Notice(this.plugin.messages.notices.deviceTypeChanged);
    }));
    new import_obsidian7.Setting(containerEl).setName("Language settings").setHeading();
    new import_obsidian7.Setting(containerEl).setName("Language").setDesc("Choose your preferred language for the plugin interface.").addDropdown((dropdown) => dropdown.addOption("en", "English").addOption("zh", "\u4E2D\u6587").setValue(this.plugin.settings.language || "en").onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      this.plugin.configManager.updateLanguage(value);
      this.plugin.config.language = value;
      this.plugin.mindMapService.updateLanguage(value);
      this.display();
      const newI18nManager = createI18nManager(value);
      const newMessages = newI18nManager.getMessages();
      const languageName = value === "en" ? "English" : "\u4E2D\u6587";
      const message = newMessages.format(
        newMessages.notices.languageChanged,
        { language: languageName }
      );
      new import_obsidian7.Notice(message);
    }));
    new import_obsidian7.Setting(containerEl).setName("AI Configuration (OpenAI-compatible API)").setHeading();
    containerEl.createEl("p", {
      text: "Configure your AI API to enable intelligent features like automatic node suggestions.",
      cls: "setting-item-description"
    });
    const securityNotice = containerEl.createDiv({ cls: "setting-item-security-notice" });
    securityNotice.createEl("strong", { text: "\u{1F512} Security:" });
    securityNotice.appendText(" Your API key is encrypted using AES-GCM (256-bit) before storage. ");
    const codeEl = securityNotice.createEl("code", { text: "data.json" });
    securityNotice.appendText(" The encrypted key is stored in ");
    securityNotice.appendChild(codeEl.cloneNode(true));
    securityNotice.appendText(" and can only be decrypted on this device.");
    new import_obsidian7.Setting(containerEl).setName("OpenAI API Base URL").setDesc("The base URL for your OpenAI-compatible API (e.g., https://api.openai.com/v1)").addText((text) => text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openaiApiBaseUrl).onChange(async (value) => {
      this.plugin.settings.openaiApiBaseUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key (starts with sk-...)").addText((text) => {
      text.setPlaceholder("sk-...");
      text.setValue(this.plugin.settings.openaiApiKey);
      text.inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
        this.plugin.aiClient.updateConfig({
          apiBaseUrl: this.plugin.settings.openaiApiBaseUrl,
          apiKey: value,
          model: this.plugin.settings.openaiModel
        });
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Model name").setDesc("The model name to use (e.g., gpt-3.5-turbo, gpt-4, llama2, mistral, etc.)").addText((text) => text.setPlaceholder("gpt-3.5-turbo").setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
      this.plugin.settings.openaiModel = value;
      await this.plugin.saveSettings();
      this.plugin.aiClient.updateConfig({
        apiBaseUrl: this.plugin.settings.openaiApiBaseUrl,
        apiKey: this.plugin.settings.openaiApiKey,
        model: value
      });
    }));
    const testButtonContainer = containerEl.createDiv({ cls: "setting-item" });
    const testButtonDesc = testButtonContainer.createDiv({ cls: "setting-item-info" });
    testButtonDesc.createDiv({ cls: "setting-item-name", text: "Test connection" });
    testButtonDesc.createDiv({ cls: "setting-item-description", text: "Test your API configuration to ensure it works correctly" });
    const testButtonControl = testButtonContainer.createDiv({ cls: "setting-item-control" });
    this.testButton = testButtonControl.createEl("button", {
      text: "Test connection",
      cls: "mod-cta"
    });
    let resultEl = null;
    this.testButtonHandler = async () => {
      if (resultEl) {
        resultEl.remove();
      }
      this.testButton.textContent = "Testing...";
      this.testButton.disabled = true;
      try {
        const TIMEOUT_MS = 1e4;
        const testPromise = this.plugin.aiClient.testConnection();
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            reject(new Error(this.plugin.messages.notices.apiTestTimeout));
          }, TIMEOUT_MS);
        });
        const result = await Promise.race([testPromise, timeoutPromise]);
        resultEl = testButtonControl.createDiv({
          cls: `ai-test-result ${result.success ? "success" : "error"}`
        });
        resultEl.textContent = result.message;
        if (result.success) {
          new import_obsidian7.Notice(this.plugin.messages.notices.apiConnectionSuccess);
        } else {
          new import_obsidian7.Notice(this.plugin.messages.notices.apiConnectionFailed);
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        resultEl = testButtonControl.createDiv({
          cls: "ai-test-result error"
        });
        resultEl.textContent = `\u274C Error: ${errorMessage}`;
        new import_obsidian7.Notice(this.plugin.messages.notices.connectionTestFailed);
      } finally {
        if (this.testButton) {
          this.testButton.textContent = "Test connection";
          this.testButton.disabled = false;
        }
      }
    };
    this.testButton.addEventListener("click", this.testButtonHandler);
    new import_obsidian7.Setting(containerEl).setName("AI Prompt Configuration").setHeading();
    containerEl.createEl("p", {
      text: "Customize how the AI generates suggestions by editing the system message and prompt template.",
      cls: "setting-item-description"
    });
    new import_obsidian7.Setting(containerEl).setName("AI System Message").setDesc("Define the AI assistant role and behavior. This sets the context for all AI interactions.").addTextArea((text) => {
      text.setPlaceholder("You are a helpful mind map assistant...");
      text.setValue(this.plugin.settings.aiSystemMessage);
      text.onChange(async (value) => {
        this.plugin.settings.aiSystemMessage = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("AI Prompt Template").setDesc("Customize the prompt template for node suggestions. Available variables: {nodeText}, {level}, {parentContext}, {siblingsContext}, {existingChildren}, {centralTopic}").addTextArea((text) => {
      text.setPlaceholder("Please suggest 3-5 child nodes...");
      text.setValue(this.plugin.settings.aiPromptTemplate);
      text.onChange(async (value) => {
        this.plugin.settings.aiPromptTemplate = value;
        await this.plugin.saveSettings();
      });
    });
    const variablesRef = containerEl.createDiv({ cls: "prompt-variables-reference" });
    variablesRef.createEl("strong", { text: "Available variables:" });
    const ul = variablesRef.createEl("ul");
    const variables = [
      { code: "{nodeText}", desc: "Current node text" },
      { code: "{level}", desc: "Node hierarchy level (0=root)" },
      { code: "{parentContext}", desc: "Parent node info (if exists)" },
      { code: "{siblingsContext}", desc: "Sibling nodes (if exists)" },
      { code: "{existingChildren}", desc: "Already existing children" },
      { code: "{centralTopic}", desc: "Central topic (root node text)" }
    ];
    for (const v of variables) {
      const li = ul.createEl("li");
      li.createEl("code", { text: v.code });
      li.appendText(` - ${v.desc}`);
    }
    new import_obsidian7.Setting(containerEl).setName("Reset Prompts").setDesc("Reset prompt templates to default values").addButton((button) => button.setButtonText("Reset to Defaults").setWarning().onClick(async () => {
      this.plugin.settings.aiSystemMessage = DEFAULT_SETTINGS.aiSystemMessage;
      this.plugin.settings.aiPromptTemplate = DEFAULT_SETTINGS.aiPromptTemplate;
      await this.plugin.saveSettings();
      this.display();
      new import_obsidian7.Notice(this.plugin.messages.notices.promptsReset);
    }));
  }
};
